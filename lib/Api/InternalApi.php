<?php
/**
 * InternalApi
 * PHP version 7.4
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Probatix API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 2.0.0
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 7.0.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * InternalApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class InternalApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'apiApiInternalcustomPrintingWorkflowsGetCollection' => [
            'application/json',
        ],
        'apiApiInternalcustomPrintingWorkflowsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalcustomPrintingWorkflowsUuidGet' => [
            'application/json',
        ],
        'apiApiInternalcustomPrintingWorkflowsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalcustomersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalcustomersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalcustomersUuidGet' => [
            'application/json',
        ],
        'apiApiInternalcustomersUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternaldocumentsGetCollection' => [
            'application/json',
        ],
        'apiApiInternaldocumentsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternaldocumentsUuidGet' => [
            'application/json',
        ],
        'apiApiInternaldocumentsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternallocationsGetCollection' => [
            'application/json',
        ],
        'apiApiInternallocationsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternallocationsUuidGet' => [
            'application/json',
        ],
        'apiApiInternallocationsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalorderProductsGetCollection' => [
            'application/json',
        ],
        'apiApiInternalorderProductsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalorderProductsUuidGet' => [
            'application/json',
        ],
        'apiApiInternalorderProductsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalorderVouchersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalorderVouchersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalorderVouchersUuidGet' => [
            'application/json',
        ],
        'apiApiInternalorderVouchersUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalordersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalordersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalordersUuidGet' => [
            'application/json',
        ],
        'apiApiInternalordersUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalpatientEventsGetCollection' => [
            'application/json',
        ],
        'apiApiInternalpatientEventsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalpatientEventsUuidGet' => [
            'application/json',
        ],
        'apiApiInternalpatientEventsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalpatientsGetCollection' => [
            'application/json',
        ],
        'apiApiInternalpatientsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalpatientsUuidGet' => [
            'application/json',
        ],
        'apiApiInternalpatientsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalprobeIdentifiersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalprobeIdentifiersIdGet' => [
            'application/json',
        ],
        'apiApiInternalprobeIdentifiersIdPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalprobeIdentifiersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalproductsGetCollection' => [
            'application/json',
        ],
        'apiApiInternalproductsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalproductsUuidGet' => [
            'application/json',
        ],
        'apiApiInternalproductsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternaltenantsGetCollection' => [
            'application/json',
        ],
        'apiApiInternaltenantsPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternaltenantsUuidGet' => [
            'application/json',
        ],
        'apiApiInternaltenantsUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalusersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalusersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalusersUuidGet' => [
            'application/json',
        ],
        'apiApiInternalusersUuidPatch' => [
            'application/merge-patch+json',
        ],
        'apiApiInternalvouchersGetCollection' => [
            'application/json',
        ],
        'apiApiInternalvouchersPost' => [
            'application/json',
            'application/ld+json',
        ],
        'apiApiInternalvouchersUuidGet' => [
            'application/json',
        ],
        'apiApiInternalvouchersUuidPatch' => [
            'application/merge-patch+json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsGetCollection
     *
     * Retrieves the collection of CustomPrintingWorkflow resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $type  (optional)
     * @param  string[] $type2  (optional)
     * @param  string $labels  (optional)
     * @param  string[] $labels2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomPrintingWorkflow[]
     */
    public function apiApiInternalcustomPrintingWorkflowsGetCollection($page = 1, $type = null, $type2 = null, $labels = null, $labels2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'][0])
    {
        list($response) = $this->apiApiInternalcustomPrintingWorkflowsGetCollectionWithHttpInfo($page, $type, $type2, $labels, $labels2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of CustomPrintingWorkflow resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $type  (optional)
     * @param  string[] $type2  (optional)
     * @param  string $labels  (optional)
     * @param  string[] $labels2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomPrintingWorkflow[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomPrintingWorkflowsGetCollectionWithHttpInfo($page = 1, $type = null, $type2 = null, $labels = null, $labels2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'][0])
    {
        $request = $this->apiApiInternalcustomPrintingWorkflowsGetCollectionRequest($page, $type, $type2, $labels, $labels2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomPrintingWorkflow[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomPrintingWorkflow[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomPrintingWorkflow[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomPrintingWorkflow[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsGetCollectionAsync
     *
     * Retrieves the collection of CustomPrintingWorkflow resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $type  (optional)
     * @param  string[] $type2  (optional)
     * @param  string $labels  (optional)
     * @param  string[] $labels2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsGetCollectionAsync($page = 1, $type = null, $type2 = null, $labels = null, $labels2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'][0])
    {
        return $this->apiApiInternalcustomPrintingWorkflowsGetCollectionAsyncWithHttpInfo($page, $type, $type2, $labels, $labels2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of CustomPrintingWorkflow resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $type  (optional)
     * @param  string[] $type2  (optional)
     * @param  string $labels  (optional)
     * @param  string[] $labels2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsGetCollectionAsyncWithHttpInfo($page = 1, $type = null, $type2 = null, $labels = null, $labels2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow[]';
        $request = $this->apiApiInternalcustomPrintingWorkflowsGetCollectionRequest($page, $type, $type2, $labels, $labels2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomPrintingWorkflowsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $type  (optional)
     * @param  string[] $type2  (optional)
     * @param  string $labels  (optional)
     * @param  string[] $labels2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomPrintingWorkflowsGetCollectionRequest($page = 1, $type = null, $type2 = null, $labels = null, $labels2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsGetCollection'][0])
    {













        $resourcePath = '/api-internal/custom_printing_workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type,
            'type', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $type2,
            'type[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels,
            'labels', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $labels2,
            'labels[]', // param base name
            'array', // openApiType
            'deepObject', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsPost
     *
     * Creates a CustomPrintingWorkflow resource.
     *
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The new CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomPrintingWorkflow
     */
    public function apiApiInternalcustomPrintingWorkflowsPost($custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'][0])
    {
        list($response) = $this->apiApiInternalcustomPrintingWorkflowsPostWithHttpInfo($custom_printing_workflow, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsPostWithHttpInfo
     *
     * Creates a CustomPrintingWorkflow resource.
     *
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The new CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomPrintingWorkflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomPrintingWorkflowsPostWithHttpInfo($custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'][0])
    {
        $request = $this->apiApiInternalcustomPrintingWorkflowsPostRequest($custom_printing_workflow, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomPrintingWorkflow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomPrintingWorkflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsPostAsync
     *
     * Creates a CustomPrintingWorkflow resource.
     *
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The new CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsPostAsync($custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'][0])
    {
        return $this->apiApiInternalcustomPrintingWorkflowsPostAsyncWithHttpInfo($custom_printing_workflow, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsPostAsyncWithHttpInfo
     *
     * Creates a CustomPrintingWorkflow resource.
     *
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The new CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsPostAsyncWithHttpInfo($custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
        $request = $this->apiApiInternalcustomPrintingWorkflowsPostRequest($custom_printing_workflow, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomPrintingWorkflowsPost'
     *
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The new CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomPrintingWorkflowsPostRequest($custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsPost'][0])
    {

        // verify the required parameter 'custom_printing_workflow' is set
        if ($custom_printing_workflow === null || (is_array($custom_printing_workflow) && count($custom_printing_workflow) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_printing_workflow when calling apiApiInternalcustomPrintingWorkflowsPost'
            );
        }


        $resourcePath = '/api-internal/custom_printing_workflows';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_printing_workflow)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_printing_workflow));
            } else {
                $httpBody = $custom_printing_workflow;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidGet
     *
     * Retrieves a CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomPrintingWorkflow
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'][0])
    {
        list($response) = $this->apiApiInternalcustomPrintingWorkflowsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidGetWithHttpInfo
     *
     * Retrieves a CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomPrintingWorkflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'][0])
    {
        $request = $this->apiApiInternalcustomPrintingWorkflowsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomPrintingWorkflow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomPrintingWorkflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidGetAsync
     *
     * Retrieves a CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'][0])
    {
        return $this->apiApiInternalcustomPrintingWorkflowsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
        $request = $this->apiApiInternalcustomPrintingWorkflowsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomPrintingWorkflowsUuidGet'
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalcustomPrintingWorkflowsUuidGet'
            );
        }


        $resourcePath = '/api-internal/custom_printing_workflows/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidPatch
     *
     * Updates the CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The updated CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\CustomPrintingWorkflow
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidPatch($uuid, $custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalcustomPrintingWorkflowsUuidPatchWithHttpInfo($uuid, $custom_printing_workflow, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidPatchWithHttpInfo
     *
     * Updates the CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The updated CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\CustomPrintingWorkflow, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidPatchWithHttpInfo($uuid, $custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'][0])
    {
        $request = $this->apiApiInternalcustomPrintingWorkflowsUuidPatchRequest($uuid, $custom_printing_workflow, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\CustomPrintingWorkflow' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\CustomPrintingWorkflow', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\CustomPrintingWorkflow',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidPatchAsync
     *
     * Updates the CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The updated CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidPatchAsync($uuid, $custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'][0])
    {
        return $this->apiApiInternalcustomPrintingWorkflowsUuidPatchAsyncWithHttpInfo($uuid, $custom_printing_workflow, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomPrintingWorkflowsUuidPatchAsyncWithHttpInfo
     *
     * Updates the CustomPrintingWorkflow resource.
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The updated CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidPatchAsyncWithHttpInfo($uuid, $custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\CustomPrintingWorkflow';
        $request = $this->apiApiInternalcustomPrintingWorkflowsUuidPatchRequest($uuid, $custom_printing_workflow, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomPrintingWorkflowsUuidPatch'
     *
     * @param  string $uuid CustomPrintingWorkflow identifier (required)
     * @param  \OpenAPI\Client\Model\CustomPrintingWorkflow $custom_printing_workflow The updated CustomPrintingWorkflow resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomPrintingWorkflowsUuidPatchRequest($uuid, $custom_printing_workflow, string $contentType = self::contentTypes['apiApiInternalcustomPrintingWorkflowsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalcustomPrintingWorkflowsUuidPatch'
            );
        }

        // verify the required parameter 'custom_printing_workflow' is set
        if ($custom_printing_workflow === null || (is_array($custom_printing_workflow) && count($custom_printing_workflow) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $custom_printing_workflow when calling apiApiInternalcustomPrintingWorkflowsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/custom_printing_workflows/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($custom_printing_workflow)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($custom_printing_workflow));
            } else {
                $httpBody = $custom_printing_workflow;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomersGetCollection
     *
     * Retrieves the collection of Customer resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $billing_address_street  (optional)
     * @param  string[] $billing_address_street2  (optional)
     * @param  string $billing_address_zip_code  (optional)
     * @param  string[] $billing_address_zip_code2  (optional)
     * @param  string $billing_address_city  (optional)
     * @param  string[] $billing_address_city2  (optional)
     * @param  string $billing_address_country  (optional)
     * @param  string[] $billing_address_country2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer[]
     */
    public function apiApiInternalcustomersGetCollection($page = 1, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $company = null, $company2 = null, $billing_address_street = null, $billing_address_street2 = null, $billing_address_zip_code = null, $billing_address_zip_code2 = null, $billing_address_city = null, $billing_address_city2 = null, $billing_address_country = null, $billing_address_country2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, $hash_signature = null, $hash_signature2 = null, string $contentType = self::contentTypes['apiApiInternalcustomersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalcustomersGetCollectionWithHttpInfo($page, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $company, $company2, $billing_address_street, $billing_address_street2, $billing_address_zip_code, $billing_address_zip_code2, $billing_address_city, $billing_address_city2, $billing_address_country, $billing_address_country2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $hash_signature, $hash_signature2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Customer resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $billing_address_street  (optional)
     * @param  string[] $billing_address_street2  (optional)
     * @param  string $billing_address_zip_code  (optional)
     * @param  string[] $billing_address_zip_code2  (optional)
     * @param  string $billing_address_city  (optional)
     * @param  string[] $billing_address_city2  (optional)
     * @param  string $billing_address_country  (optional)
     * @param  string[] $billing_address_country2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomersGetCollectionWithHttpInfo($page = 1, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $company = null, $company2 = null, $billing_address_street = null, $billing_address_street2 = null, $billing_address_zip_code = null, $billing_address_zip_code2 = null, $billing_address_city = null, $billing_address_city2 = null, $billing_address_country = null, $billing_address_country2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, $hash_signature = null, $hash_signature2 = null, string $contentType = self::contentTypes['apiApiInternalcustomersGetCollection'][0])
    {
        $request = $this->apiApiInternalcustomersGetCollectionRequest($page, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $company, $company2, $billing_address_street, $billing_address_street2, $billing_address_zip_code, $billing_address_zip_code2, $billing_address_city, $billing_address_city2, $billing_address_country, $billing_address_country2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $hash_signature, $hash_signature2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Customer[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomersGetCollectionAsync
     *
     * Retrieves the collection of Customer resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $billing_address_street  (optional)
     * @param  string[] $billing_address_street2  (optional)
     * @param  string $billing_address_zip_code  (optional)
     * @param  string[] $billing_address_zip_code2  (optional)
     * @param  string $billing_address_city  (optional)
     * @param  string[] $billing_address_city2  (optional)
     * @param  string $billing_address_country  (optional)
     * @param  string[] $billing_address_country2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersGetCollectionAsync($page = 1, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $company = null, $company2 = null, $billing_address_street = null, $billing_address_street2 = null, $billing_address_zip_code = null, $billing_address_zip_code2 = null, $billing_address_city = null, $billing_address_city2 = null, $billing_address_country = null, $billing_address_country2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, $hash_signature = null, $hash_signature2 = null, string $contentType = self::contentTypes['apiApiInternalcustomersGetCollection'][0])
    {
        return $this->apiApiInternalcustomersGetCollectionAsyncWithHttpInfo($page, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $company, $company2, $billing_address_street, $billing_address_street2, $billing_address_zip_code, $billing_address_zip_code2, $billing_address_city, $billing_address_city2, $billing_address_country, $billing_address_country2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $hash_signature, $hash_signature2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Customer resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $billing_address_street  (optional)
     * @param  string[] $billing_address_street2  (optional)
     * @param  string $billing_address_zip_code  (optional)
     * @param  string[] $billing_address_zip_code2  (optional)
     * @param  string $billing_address_city  (optional)
     * @param  string[] $billing_address_city2  (optional)
     * @param  string $billing_address_country  (optional)
     * @param  string[] $billing_address_country2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersGetCollectionAsyncWithHttpInfo($page = 1, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $company = null, $company2 = null, $billing_address_street = null, $billing_address_street2 = null, $billing_address_zip_code = null, $billing_address_zip_code2 = null, $billing_address_city = null, $billing_address_city2 = null, $billing_address_country = null, $billing_address_country2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, $hash_signature = null, $hash_signature2 = null, string $contentType = self::contentTypes['apiApiInternalcustomersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer[]';
        $request = $this->apiApiInternalcustomersGetCollectionRequest($page, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $company, $company2, $billing_address_street, $billing_address_street2, $billing_address_zip_code, $billing_address_zip_code2, $billing_address_city, $billing_address_city2, $billing_address_country, $billing_address_country2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $hash_signature, $hash_signature2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $billing_address_street  (optional)
     * @param  string[] $billing_address_street2  (optional)
     * @param  string $billing_address_zip_code  (optional)
     * @param  string[] $billing_address_zip_code2  (optional)
     * @param  string $billing_address_city  (optional)
     * @param  string[] $billing_address_city2  (optional)
     * @param  string $billing_address_country  (optional)
     * @param  string[] $billing_address_country2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomersGetCollectionRequest($page = 1, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $company = null, $company2 = null, $billing_address_street = null, $billing_address_street2 = null, $billing_address_zip_code = null, $billing_address_zip_code2 = null, $billing_address_city = null, $billing_address_city2 = null, $billing_address_country = null, $billing_address_country2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, $hash_signature = null, $hash_signature2 = null, string $contentType = self::contentTypes['apiApiInternalcustomersGetCollection'][0])
    {



























        $resourcePath = '/api-internal/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name2,
            'firstName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name2,
            'lastName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email2,
            'email[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company2,
            'company[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_street,
            'billingAddressStreet', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_street2,
            'billingAddressStreet[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_zip_code,
            'billingAddressZipCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_zip_code2,
            'billingAddressZipCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_city,
            'billingAddressCity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_city2,
            'billingAddressCity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_country,
            'billingAddressCountry', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $billing_address_country2,
            'billingAddressCountry[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature,
            'hashSignature', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature2,
            'hashSignature[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomersPost
     *
     * Creates a Customer resource.
     *
     * @param  \OpenAPI\Client\Model\Customer $customer The new Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer
     */
    public function apiApiInternalcustomersPost($customer, string $contentType = self::contentTypes['apiApiInternalcustomersPost'][0])
    {
        list($response) = $this->apiApiInternalcustomersPostWithHttpInfo($customer, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomersPostWithHttpInfo
     *
     * Creates a Customer resource.
     *
     * @param  \OpenAPI\Client\Model\Customer $customer The new Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomersPostWithHttpInfo($customer, string $contentType = self::contentTypes['apiApiInternalcustomersPost'][0])
    {
        $request = $this->apiApiInternalcustomersPostRequest($customer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Customer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomersPostAsync
     *
     * Creates a Customer resource.
     *
     * @param  \OpenAPI\Client\Model\Customer $customer The new Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersPostAsync($customer, string $contentType = self::contentTypes['apiApiInternalcustomersPost'][0])
    {
        return $this->apiApiInternalcustomersPostAsyncWithHttpInfo($customer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomersPostAsyncWithHttpInfo
     *
     * Creates a Customer resource.
     *
     * @param  \OpenAPI\Client\Model\Customer $customer The new Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersPostAsyncWithHttpInfo($customer, string $contentType = self::contentTypes['apiApiInternalcustomersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer';
        $request = $this->apiApiInternalcustomersPostRequest($customer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomersPost'
     *
     * @param  \OpenAPI\Client\Model\Customer $customer The new Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomersPostRequest($customer, string $contentType = self::contentTypes['apiApiInternalcustomersPost'][0])
    {

        // verify the required parameter 'customer' is set
        if ($customer === null || (is_array($customer) && count($customer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer when calling apiApiInternalcustomersPost'
            );
        }


        $resourcePath = '/api-internal/customers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer));
            } else {
                $httpBody = $customer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomersUuidGet
     *
     * Retrieves a Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer
     */
    public function apiApiInternalcustomersUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalcustomersUuidGet'][0])
    {
        list($response) = $this->apiApiInternalcustomersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomersUuidGetWithHttpInfo
     *
     * Retrieves a Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalcustomersUuidGet'][0])
    {
        $request = $this->apiApiInternalcustomersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Customer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomersUuidGetAsync
     *
     * Retrieves a Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalcustomersUuidGet'][0])
    {
        return $this->apiApiInternalcustomersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomersUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalcustomersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer';
        $request = $this->apiApiInternalcustomersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomersUuidGet'
     *
     * @param  string $uuid Customer identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomersUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalcustomersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalcustomersUuidGet'
            );
        }


        $resourcePath = '/api-internal/customers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalcustomersUuidPatch
     *
     * Updates the Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  \OpenAPI\Client\Model\Customer $customer The updated Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Customer
     */
    public function apiApiInternalcustomersUuidPatch($uuid, $customer, string $contentType = self::contentTypes['apiApiInternalcustomersUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalcustomersUuidPatchWithHttpInfo($uuid, $customer, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalcustomersUuidPatchWithHttpInfo
     *
     * Updates the Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  \OpenAPI\Client\Model\Customer $customer The updated Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Customer, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalcustomersUuidPatchWithHttpInfo($uuid, $customer, string $contentType = self::contentTypes['apiApiInternalcustomersUuidPatch'][0])
    {
        $request = $this->apiApiInternalcustomersUuidPatchRequest($uuid, $customer, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Customer' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Customer' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Customer', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Customer';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Customer',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalcustomersUuidPatchAsync
     *
     * Updates the Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  \OpenAPI\Client\Model\Customer $customer The updated Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersUuidPatchAsync($uuid, $customer, string $contentType = self::contentTypes['apiApiInternalcustomersUuidPatch'][0])
    {
        return $this->apiApiInternalcustomersUuidPatchAsyncWithHttpInfo($uuid, $customer, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalcustomersUuidPatchAsyncWithHttpInfo
     *
     * Updates the Customer resource.
     *
     * @param  string $uuid Customer identifier (required)
     * @param  \OpenAPI\Client\Model\Customer $customer The updated Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalcustomersUuidPatchAsyncWithHttpInfo($uuid, $customer, string $contentType = self::contentTypes['apiApiInternalcustomersUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Customer';
        $request = $this->apiApiInternalcustomersUuidPatchRequest($uuid, $customer, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalcustomersUuidPatch'
     *
     * @param  string $uuid Customer identifier (required)
     * @param  \OpenAPI\Client\Model\Customer $customer The updated Customer resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalcustomersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalcustomersUuidPatchRequest($uuid, $customer, string $contentType = self::contentTypes['apiApiInternalcustomersUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalcustomersUuidPatch'
            );
        }

        // verify the required parameter 'customer' is set
        if ($customer === null || (is_array($customer) && count($customer) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $customer when calling apiApiInternalcustomersUuidPatch'
            );
        }


        $resourcePath = '/api-internal/customers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($customer)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($customer));
            } else {
                $httpBody = $customer;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaldocumentsGetCollection
     *
     * Retrieves the collection of Document resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $document_file_name  (optional)
     * @param  string[] $document_file_name2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $mime_type  (optional)
     * @param  string[] $mime_type2  (optional)
     * @param  string $extension  (optional)
     * @param  string[] $extension2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document[]
     */
    public function apiApiInternaldocumentsGetCollection($page = 1, $document_file_name = null, $document_file_name2 = null, $created_at = null, $created_at2 = null, $mime_type = null, $mime_type2 = null, $extension = null, $extension2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaldocumentsGetCollection'][0])
    {
        list($response) = $this->apiApiInternaldocumentsGetCollectionWithHttpInfo($page, $document_file_name, $document_file_name2, $created_at, $created_at2, $mime_type, $mime_type2, $extension, $extension2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaldocumentsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Document resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $document_file_name  (optional)
     * @param  string[] $document_file_name2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $mime_type  (optional)
     * @param  string[] $mime_type2  (optional)
     * @param  string $extension  (optional)
     * @param  string[] $extension2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaldocumentsGetCollectionWithHttpInfo($page = 1, $document_file_name = null, $document_file_name2 = null, $created_at = null, $created_at2 = null, $mime_type = null, $mime_type2 = null, $extension = null, $extension2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaldocumentsGetCollection'][0])
    {
        $request = $this->apiApiInternaldocumentsGetCollectionRequest($page, $document_file_name, $document_file_name2, $created_at, $created_at2, $mime_type, $mime_type2, $extension, $extension2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Document[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaldocumentsGetCollectionAsync
     *
     * Retrieves the collection of Document resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $document_file_name  (optional)
     * @param  string[] $document_file_name2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $mime_type  (optional)
     * @param  string[] $mime_type2  (optional)
     * @param  string $extension  (optional)
     * @param  string[] $extension2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsGetCollectionAsync($page = 1, $document_file_name = null, $document_file_name2 = null, $created_at = null, $created_at2 = null, $mime_type = null, $mime_type2 = null, $extension = null, $extension2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaldocumentsGetCollection'][0])
    {
        return $this->apiApiInternaldocumentsGetCollectionAsyncWithHttpInfo($page, $document_file_name, $document_file_name2, $created_at, $created_at2, $mime_type, $mime_type2, $extension, $extension2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaldocumentsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Document resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $document_file_name  (optional)
     * @param  string[] $document_file_name2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $mime_type  (optional)
     * @param  string[] $mime_type2  (optional)
     * @param  string $extension  (optional)
     * @param  string[] $extension2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsGetCollectionAsyncWithHttpInfo($page = 1, $document_file_name = null, $document_file_name2 = null, $created_at = null, $created_at2 = null, $mime_type = null, $mime_type2 = null, $extension = null, $extension2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaldocumentsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Document[]';
        $request = $this->apiApiInternaldocumentsGetCollectionRequest($page, $document_file_name, $document_file_name2, $created_at, $created_at2, $mime_type, $mime_type2, $extension, $extension2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaldocumentsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $document_file_name  (optional)
     * @param  string[] $document_file_name2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $mime_type  (optional)
     * @param  string[] $mime_type2  (optional)
     * @param  string $extension  (optional)
     * @param  string[] $extension2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaldocumentsGetCollectionRequest($page = 1, $document_file_name = null, $document_file_name2 = null, $created_at = null, $created_at2 = null, $mime_type = null, $mime_type2 = null, $extension = null, $extension2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaldocumentsGetCollection'][0])
    {













        $resourcePath = '/api-internal/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_file_name,
            'documentFileName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_file_name2,
            'documentFileName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type,
            'mimeType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mime_type2,
            'mimeType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension,
            'extension', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $extension2,
            'extension[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaldocumentsPost
     *
     * Creates a Document resource.
     *
     * @param  \OpenAPI\Client\Model\Document $document The new Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document
     */
    public function apiApiInternaldocumentsPost($document, string $contentType = self::contentTypes['apiApiInternaldocumentsPost'][0])
    {
        list($response) = $this->apiApiInternaldocumentsPostWithHttpInfo($document, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaldocumentsPostWithHttpInfo
     *
     * Creates a Document resource.
     *
     * @param  \OpenAPI\Client\Model\Document $document The new Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaldocumentsPostWithHttpInfo($document, string $contentType = self::contentTypes['apiApiInternaldocumentsPost'][0])
    {
        $request = $this->apiApiInternaldocumentsPostRequest($document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Document' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Document' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaldocumentsPostAsync
     *
     * Creates a Document resource.
     *
     * @param  \OpenAPI\Client\Model\Document $document The new Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsPostAsync($document, string $contentType = self::contentTypes['apiApiInternaldocumentsPost'][0])
    {
        return $this->apiApiInternaldocumentsPostAsyncWithHttpInfo($document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaldocumentsPostAsyncWithHttpInfo
     *
     * Creates a Document resource.
     *
     * @param  \OpenAPI\Client\Model\Document $document The new Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsPostAsyncWithHttpInfo($document, string $contentType = self::contentTypes['apiApiInternaldocumentsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Document';
        $request = $this->apiApiInternaldocumentsPostRequest($document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaldocumentsPost'
     *
     * @param  \OpenAPI\Client\Model\Document $document The new Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaldocumentsPostRequest($document, string $contentType = self::contentTypes['apiApiInternaldocumentsPost'][0])
    {

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling apiApiInternaldocumentsPost'
            );
        }


        $resourcePath = '/api-internal/documents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($document)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($document));
            } else {
                $httpBody = $document;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaldocumentsUuidGet
     *
     * Retrieves a Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document
     */
    public function apiApiInternaldocumentsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidGet'][0])
    {
        list($response) = $this->apiApiInternaldocumentsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaldocumentsUuidGetWithHttpInfo
     *
     * Retrieves a Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaldocumentsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidGet'][0])
    {
        $request = $this->apiApiInternaldocumentsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Document' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaldocumentsUuidGetAsync
     *
     * Retrieves a Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidGet'][0])
    {
        return $this->apiApiInternaldocumentsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaldocumentsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Document';
        $request = $this->apiApiInternaldocumentsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaldocumentsUuidGet'
     *
     * @param  string $uuid Document identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaldocumentsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternaldocumentsUuidGet'
            );
        }


        $resourcePath = '/api-internal/documents/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaldocumentsUuidPatch
     *
     * Updates the Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  \OpenAPI\Client\Model\Document $document The updated Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Document
     */
    public function apiApiInternaldocumentsUuidPatch($uuid, $document, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternaldocumentsUuidPatchWithHttpInfo($uuid, $document, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaldocumentsUuidPatchWithHttpInfo
     *
     * Updates the Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  \OpenAPI\Client\Model\Document $document The updated Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Document, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaldocumentsUuidPatchWithHttpInfo($uuid, $document, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidPatch'][0])
    {
        $request = $this->apiApiInternaldocumentsUuidPatchRequest($uuid, $document, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Document' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Document' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Document', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Document';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Document',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaldocumentsUuidPatchAsync
     *
     * Updates the Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  \OpenAPI\Client\Model\Document $document The updated Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsUuidPatchAsync($uuid, $document, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidPatch'][0])
    {
        return $this->apiApiInternaldocumentsUuidPatchAsyncWithHttpInfo($uuid, $document, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaldocumentsUuidPatchAsyncWithHttpInfo
     *
     * Updates the Document resource.
     *
     * @param  string $uuid Document identifier (required)
     * @param  \OpenAPI\Client\Model\Document $document The updated Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaldocumentsUuidPatchAsyncWithHttpInfo($uuid, $document, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Document';
        $request = $this->apiApiInternaldocumentsUuidPatchRequest($uuid, $document, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaldocumentsUuidPatch'
     *
     * @param  string $uuid Document identifier (required)
     * @param  \OpenAPI\Client\Model\Document $document The updated Document resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaldocumentsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaldocumentsUuidPatchRequest($uuid, $document, string $contentType = self::contentTypes['apiApiInternaldocumentsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternaldocumentsUuidPatch'
            );
        }

        // verify the required parameter 'document' is set
        if ($document === null || (is_array($document) && count($document) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document when calling apiApiInternaldocumentsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/documents/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($document)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($document));
            } else {
                $httpBody = $document;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternallocationsGetCollection
     *
     * Retrieves the collection of Location resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $address  (optional)
     * @param  string[] $address2  (optional)
     * @param  bool $is_active  (optional)
     * @param  bool[] $is_active2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $latitude  (optional)
     * @param  string[] $latitude2  (optional)
     * @param  string $longitude  (optional)
     * @param  string[] $longitude2  (optional)
     * @param  string $vicinity  (optional)
     * @param  string[] $vicinity2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $test_center_id  (optional)
     * @param  string[] $test_center_id2  (optional)
     * @param  string $leading_doctor_name  (optional)
     * @param  string[] $leading_doctor_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $street_name  (optional)
     * @param  string[] $street_name2  (optional)
     * @param  string $house_number  (optional)
     * @param  string[] $house_number2  (optional)
     * @param  string $postal_code  (optional)
     * @param  string[] $postal_code2  (optional)
     * @param  string $locality  (optional)
     * @param  string[] $locality2  (optional)
     * @param  string $state  (optional)
     * @param  string[] $state2  (optional)
     * @param  string $country_code  (optional)
     * @param  string[] $country_code2  (optional)
     * @param  bool $archived  (optional)
     * @param  bool[] $archived2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Location[]
     */
    public function apiApiInternallocationsGetCollection($page = 1, $url_key = null, $url_key2 = null, $name = null, $name2 = null, $address = null, $address2 = null, $is_active = null, $is_active2 = null, $description = null, $description2 = null, $address_components = null, $address_components2 = null, $latitude = null, $latitude2 = null, $longitude = null, $longitude2 = null, $vicinity = null, $vicinity2 = null, $phone_number = null, $phone_number2 = null, $test_center_id = null, $test_center_id2 = null, $leading_doctor_name = null, $leading_doctor_name2 = null, $email = null, $email2 = null, $street_name = null, $street_name2 = null, $house_number = null, $house_number2 = null, $postal_code = null, $postal_code2 = null, $locality = null, $locality2 = null, $state = null, $state2 = null, $country_code = null, $country_code2 = null, $archived = null, $archived2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternallocationsGetCollection'][0])
    {
        list($response) = $this->apiApiInternallocationsGetCollectionWithHttpInfo($page, $url_key, $url_key2, $name, $name2, $address, $address2, $is_active, $is_active2, $description, $description2, $address_components, $address_components2, $latitude, $latitude2, $longitude, $longitude2, $vicinity, $vicinity2, $phone_number, $phone_number2, $test_center_id, $test_center_id2, $leading_doctor_name, $leading_doctor_name2, $email, $email2, $street_name, $street_name2, $house_number, $house_number2, $postal_code, $postal_code2, $locality, $locality2, $state, $state2, $country_code, $country_code2, $archived, $archived2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternallocationsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Location resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $address  (optional)
     * @param  string[] $address2  (optional)
     * @param  bool $is_active  (optional)
     * @param  bool[] $is_active2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $latitude  (optional)
     * @param  string[] $latitude2  (optional)
     * @param  string $longitude  (optional)
     * @param  string[] $longitude2  (optional)
     * @param  string $vicinity  (optional)
     * @param  string[] $vicinity2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $test_center_id  (optional)
     * @param  string[] $test_center_id2  (optional)
     * @param  string $leading_doctor_name  (optional)
     * @param  string[] $leading_doctor_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $street_name  (optional)
     * @param  string[] $street_name2  (optional)
     * @param  string $house_number  (optional)
     * @param  string[] $house_number2  (optional)
     * @param  string $postal_code  (optional)
     * @param  string[] $postal_code2  (optional)
     * @param  string $locality  (optional)
     * @param  string[] $locality2  (optional)
     * @param  string $state  (optional)
     * @param  string[] $state2  (optional)
     * @param  string $country_code  (optional)
     * @param  string[] $country_code2  (optional)
     * @param  bool $archived  (optional)
     * @param  bool[] $archived2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Location[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternallocationsGetCollectionWithHttpInfo($page = 1, $url_key = null, $url_key2 = null, $name = null, $name2 = null, $address = null, $address2 = null, $is_active = null, $is_active2 = null, $description = null, $description2 = null, $address_components = null, $address_components2 = null, $latitude = null, $latitude2 = null, $longitude = null, $longitude2 = null, $vicinity = null, $vicinity2 = null, $phone_number = null, $phone_number2 = null, $test_center_id = null, $test_center_id2 = null, $leading_doctor_name = null, $leading_doctor_name2 = null, $email = null, $email2 = null, $street_name = null, $street_name2 = null, $house_number = null, $house_number2 = null, $postal_code = null, $postal_code2 = null, $locality = null, $locality2 = null, $state = null, $state2 = null, $country_code = null, $country_code2 = null, $archived = null, $archived2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternallocationsGetCollection'][0])
    {
        $request = $this->apiApiInternallocationsGetCollectionRequest($page, $url_key, $url_key2, $name, $name2, $address, $address2, $is_active, $is_active2, $description, $description2, $address_components, $address_components2, $latitude, $latitude2, $longitude, $longitude2, $vicinity, $vicinity2, $phone_number, $phone_number2, $test_center_id, $test_center_id2, $leading_doctor_name, $leading_doctor_name2, $email, $email2, $street_name, $street_name2, $house_number, $house_number2, $postal_code, $postal_code2, $locality, $locality2, $state, $state2, $country_code, $country_code2, $archived, $archived2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Location[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Location[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Location[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Location[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Location[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternallocationsGetCollectionAsync
     *
     * Retrieves the collection of Location resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $address  (optional)
     * @param  string[] $address2  (optional)
     * @param  bool $is_active  (optional)
     * @param  bool[] $is_active2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $latitude  (optional)
     * @param  string[] $latitude2  (optional)
     * @param  string $longitude  (optional)
     * @param  string[] $longitude2  (optional)
     * @param  string $vicinity  (optional)
     * @param  string[] $vicinity2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $test_center_id  (optional)
     * @param  string[] $test_center_id2  (optional)
     * @param  string $leading_doctor_name  (optional)
     * @param  string[] $leading_doctor_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $street_name  (optional)
     * @param  string[] $street_name2  (optional)
     * @param  string $house_number  (optional)
     * @param  string[] $house_number2  (optional)
     * @param  string $postal_code  (optional)
     * @param  string[] $postal_code2  (optional)
     * @param  string $locality  (optional)
     * @param  string[] $locality2  (optional)
     * @param  string $state  (optional)
     * @param  string[] $state2  (optional)
     * @param  string $country_code  (optional)
     * @param  string[] $country_code2  (optional)
     * @param  bool $archived  (optional)
     * @param  bool[] $archived2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsGetCollectionAsync($page = 1, $url_key = null, $url_key2 = null, $name = null, $name2 = null, $address = null, $address2 = null, $is_active = null, $is_active2 = null, $description = null, $description2 = null, $address_components = null, $address_components2 = null, $latitude = null, $latitude2 = null, $longitude = null, $longitude2 = null, $vicinity = null, $vicinity2 = null, $phone_number = null, $phone_number2 = null, $test_center_id = null, $test_center_id2 = null, $leading_doctor_name = null, $leading_doctor_name2 = null, $email = null, $email2 = null, $street_name = null, $street_name2 = null, $house_number = null, $house_number2 = null, $postal_code = null, $postal_code2 = null, $locality = null, $locality2 = null, $state = null, $state2 = null, $country_code = null, $country_code2 = null, $archived = null, $archived2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternallocationsGetCollection'][0])
    {
        return $this->apiApiInternallocationsGetCollectionAsyncWithHttpInfo($page, $url_key, $url_key2, $name, $name2, $address, $address2, $is_active, $is_active2, $description, $description2, $address_components, $address_components2, $latitude, $latitude2, $longitude, $longitude2, $vicinity, $vicinity2, $phone_number, $phone_number2, $test_center_id, $test_center_id2, $leading_doctor_name, $leading_doctor_name2, $email, $email2, $street_name, $street_name2, $house_number, $house_number2, $postal_code, $postal_code2, $locality, $locality2, $state, $state2, $country_code, $country_code2, $archived, $archived2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternallocationsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Location resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $address  (optional)
     * @param  string[] $address2  (optional)
     * @param  bool $is_active  (optional)
     * @param  bool[] $is_active2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $latitude  (optional)
     * @param  string[] $latitude2  (optional)
     * @param  string $longitude  (optional)
     * @param  string[] $longitude2  (optional)
     * @param  string $vicinity  (optional)
     * @param  string[] $vicinity2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $test_center_id  (optional)
     * @param  string[] $test_center_id2  (optional)
     * @param  string $leading_doctor_name  (optional)
     * @param  string[] $leading_doctor_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $street_name  (optional)
     * @param  string[] $street_name2  (optional)
     * @param  string $house_number  (optional)
     * @param  string[] $house_number2  (optional)
     * @param  string $postal_code  (optional)
     * @param  string[] $postal_code2  (optional)
     * @param  string $locality  (optional)
     * @param  string[] $locality2  (optional)
     * @param  string $state  (optional)
     * @param  string[] $state2  (optional)
     * @param  string $country_code  (optional)
     * @param  string[] $country_code2  (optional)
     * @param  bool $archived  (optional)
     * @param  bool[] $archived2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsGetCollectionAsyncWithHttpInfo($page = 1, $url_key = null, $url_key2 = null, $name = null, $name2 = null, $address = null, $address2 = null, $is_active = null, $is_active2 = null, $description = null, $description2 = null, $address_components = null, $address_components2 = null, $latitude = null, $latitude2 = null, $longitude = null, $longitude2 = null, $vicinity = null, $vicinity2 = null, $phone_number = null, $phone_number2 = null, $test_center_id = null, $test_center_id2 = null, $leading_doctor_name = null, $leading_doctor_name2 = null, $email = null, $email2 = null, $street_name = null, $street_name2 = null, $house_number = null, $house_number2 = null, $postal_code = null, $postal_code2 = null, $locality = null, $locality2 = null, $state = null, $state2 = null, $country_code = null, $country_code2 = null, $archived = null, $archived2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternallocationsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Location[]';
        $request = $this->apiApiInternallocationsGetCollectionRequest($page, $url_key, $url_key2, $name, $name2, $address, $address2, $is_active, $is_active2, $description, $description2, $address_components, $address_components2, $latitude, $latitude2, $longitude, $longitude2, $vicinity, $vicinity2, $phone_number, $phone_number2, $test_center_id, $test_center_id2, $leading_doctor_name, $leading_doctor_name2, $email, $email2, $street_name, $street_name2, $house_number, $house_number2, $postal_code, $postal_code2, $locality, $locality2, $state, $state2, $country_code, $country_code2, $archived, $archived2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternallocationsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $address  (optional)
     * @param  string[] $address2  (optional)
     * @param  bool $is_active  (optional)
     * @param  bool[] $is_active2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $latitude  (optional)
     * @param  string[] $latitude2  (optional)
     * @param  string $longitude  (optional)
     * @param  string[] $longitude2  (optional)
     * @param  string $vicinity  (optional)
     * @param  string[] $vicinity2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $test_center_id  (optional)
     * @param  string[] $test_center_id2  (optional)
     * @param  string $leading_doctor_name  (optional)
     * @param  string[] $leading_doctor_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $street_name  (optional)
     * @param  string[] $street_name2  (optional)
     * @param  string $house_number  (optional)
     * @param  string[] $house_number2  (optional)
     * @param  string $postal_code  (optional)
     * @param  string[] $postal_code2  (optional)
     * @param  string $locality  (optional)
     * @param  string[] $locality2  (optional)
     * @param  string $state  (optional)
     * @param  string[] $state2  (optional)
     * @param  string $country_code  (optional)
     * @param  string[] $country_code2  (optional)
     * @param  bool $archived  (optional)
     * @param  bool[] $archived2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternallocationsGetCollectionRequest($page = 1, $url_key = null, $url_key2 = null, $name = null, $name2 = null, $address = null, $address2 = null, $is_active = null, $is_active2 = null, $description = null, $description2 = null, $address_components = null, $address_components2 = null, $latitude = null, $latitude2 = null, $longitude = null, $longitude2 = null, $vicinity = null, $vicinity2 = null, $phone_number = null, $phone_number2 = null, $test_center_id = null, $test_center_id2 = null, $leading_doctor_name = null, $leading_doctor_name2 = null, $email = null, $email2 = null, $street_name = null, $street_name2 = null, $house_number = null, $house_number2 = null, $postal_code = null, $postal_code2 = null, $locality = null, $locality2 = null, $state = null, $state2 = null, $country_code = null, $country_code2 = null, $archived = null, $archived2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternallocationsGetCollection'][0])
    {

















































        $resourcePath = '/api-internal/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_key,
            'urlKey', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_key2,
            'urlKey[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name2,
            'name[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address,
            'address', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address2,
            'address[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active,
            'isActive', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_active2,
            'isActive[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description2,
            'description[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_components,
            'addressComponents', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_components2,
            'addressComponents[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude,
            'latitude', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $latitude2,
            'latitude[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude,
            'longitude', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $longitude2,
            'longitude[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vicinity,
            'vicinity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vicinity2,
            'vicinity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'phoneNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number2,
            'phoneNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_center_id,
            'testCenterId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_center_id2,
            'testCenterId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $leading_doctor_name,
            'leadingDoctorName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $leading_doctor_name2,
            'leadingDoctorName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email2,
            'email[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_name,
            'streetName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $street_name2,
            'streetName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $house_number,
            'houseNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $house_number2,
            'houseNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $postal_code,
            'postalCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $postal_code2,
            'postalCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locality,
            'locality', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $locality2,
            'locality[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state,
            'state', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $state2,
            'state[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_code,
            'countryCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $country_code2,
            'countryCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived2,
            'archived[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternallocationsPost
     *
     * Creates a Location resource.
     *
     * @param  \OpenAPI\Client\Model\Location $location The new Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Location
     */
    public function apiApiInternallocationsPost($location, string $contentType = self::contentTypes['apiApiInternallocationsPost'][0])
    {
        list($response) = $this->apiApiInternallocationsPostWithHttpInfo($location, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternallocationsPostWithHttpInfo
     *
     * Creates a Location resource.
     *
     * @param  \OpenAPI\Client\Model\Location $location The new Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Location, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternallocationsPostWithHttpInfo($location, string $contentType = self::contentTypes['apiApiInternallocationsPost'][0])
    {
        $request = $this->apiApiInternallocationsPostRequest($location, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Location' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Location' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Location', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Location';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Location',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternallocationsPostAsync
     *
     * Creates a Location resource.
     *
     * @param  \OpenAPI\Client\Model\Location $location The new Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsPostAsync($location, string $contentType = self::contentTypes['apiApiInternallocationsPost'][0])
    {
        return $this->apiApiInternallocationsPostAsyncWithHttpInfo($location, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternallocationsPostAsyncWithHttpInfo
     *
     * Creates a Location resource.
     *
     * @param  \OpenAPI\Client\Model\Location $location The new Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsPostAsyncWithHttpInfo($location, string $contentType = self::contentTypes['apiApiInternallocationsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Location';
        $request = $this->apiApiInternallocationsPostRequest($location, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternallocationsPost'
     *
     * @param  \OpenAPI\Client\Model\Location $location The new Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternallocationsPostRequest($location, string $contentType = self::contentTypes['apiApiInternallocationsPost'][0])
    {

        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling apiApiInternallocationsPost'
            );
        }


        $resourcePath = '/api-internal/locations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($location)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($location));
            } else {
                $httpBody = $location;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternallocationsUuidGet
     *
     * Retrieves a Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Location
     */
    public function apiApiInternallocationsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternallocationsUuidGet'][0])
    {
        list($response) = $this->apiApiInternallocationsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternallocationsUuidGetWithHttpInfo
     *
     * Retrieves a Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Location, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternallocationsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternallocationsUuidGet'][0])
    {
        $request = $this->apiApiInternallocationsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Location' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Location' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Location', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Location';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Location',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternallocationsUuidGetAsync
     *
     * Retrieves a Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternallocationsUuidGet'][0])
    {
        return $this->apiApiInternallocationsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternallocationsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternallocationsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Location';
        $request = $this->apiApiInternallocationsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternallocationsUuidGet'
     *
     * @param  string $uuid Location identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternallocationsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternallocationsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternallocationsUuidGet'
            );
        }


        $resourcePath = '/api-internal/locations/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternallocationsUuidPatch
     *
     * Updates the Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  \OpenAPI\Client\Model\Location $location The updated Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Location
     */
    public function apiApiInternallocationsUuidPatch($uuid, $location, string $contentType = self::contentTypes['apiApiInternallocationsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternallocationsUuidPatchWithHttpInfo($uuid, $location, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternallocationsUuidPatchWithHttpInfo
     *
     * Updates the Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  \OpenAPI\Client\Model\Location $location The updated Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Location, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternallocationsUuidPatchWithHttpInfo($uuid, $location, string $contentType = self::contentTypes['apiApiInternallocationsUuidPatch'][0])
    {
        $request = $this->apiApiInternallocationsUuidPatchRequest($uuid, $location, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Location' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Location' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Location', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Location';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Location',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternallocationsUuidPatchAsync
     *
     * Updates the Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  \OpenAPI\Client\Model\Location $location The updated Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsUuidPatchAsync($uuid, $location, string $contentType = self::contentTypes['apiApiInternallocationsUuidPatch'][0])
    {
        return $this->apiApiInternallocationsUuidPatchAsyncWithHttpInfo($uuid, $location, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternallocationsUuidPatchAsyncWithHttpInfo
     *
     * Updates the Location resource.
     *
     * @param  string $uuid Location identifier (required)
     * @param  \OpenAPI\Client\Model\Location $location The updated Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternallocationsUuidPatchAsyncWithHttpInfo($uuid, $location, string $contentType = self::contentTypes['apiApiInternallocationsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Location';
        $request = $this->apiApiInternallocationsUuidPatchRequest($uuid, $location, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternallocationsUuidPatch'
     *
     * @param  string $uuid Location identifier (required)
     * @param  \OpenAPI\Client\Model\Location $location The updated Location resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternallocationsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternallocationsUuidPatchRequest($uuid, $location, string $contentType = self::contentTypes['apiApiInternallocationsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternallocationsUuidPatch'
            );
        }

        // verify the required parameter 'location' is set
        if ($location === null || (is_array($location) && count($location) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $location when calling apiApiInternallocationsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/locations/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($location)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($location));
            } else {
                $httpBody = $location;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderProductsGetCollection
     *
     * Retrieves the collection of OrderProduct resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  int $vat_per_unit  (optional)
     * @param  int[] $vat_per_unit2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProduct[]
     */
    public function apiApiInternalorderProductsGetCollection($page = 1, $name = null, $name2 = null, $vat_per_unit = null, $vat_per_unit2 = null, $test_type = null, $test_type2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderProductsGetCollection'][0])
    {
        list($response) = $this->apiApiInternalorderProductsGetCollectionWithHttpInfo($page, $name, $name2, $vat_per_unit, $vat_per_unit2, $test_type, $test_type2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderProductsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of OrderProduct resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  int $vat_per_unit  (optional)
     * @param  int[] $vat_per_unit2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProduct[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderProductsGetCollectionWithHttpInfo($page = 1, $name = null, $name2 = null, $vat_per_unit = null, $vat_per_unit2 = null, $test_type = null, $test_type2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderProductsGetCollection'][0])
    {
        $request = $this->apiApiInternalorderProductsGetCollectionRequest($page, $name, $name2, $vat_per_unit, $vat_per_unit2, $test_type, $test_type2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProduct[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderProduct[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProduct[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProduct[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProduct[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderProductsGetCollectionAsync
     *
     * Retrieves the collection of OrderProduct resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  int $vat_per_unit  (optional)
     * @param  int[] $vat_per_unit2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsGetCollectionAsync($page = 1, $name = null, $name2 = null, $vat_per_unit = null, $vat_per_unit2 = null, $test_type = null, $test_type2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderProductsGetCollection'][0])
    {
        return $this->apiApiInternalorderProductsGetCollectionAsyncWithHttpInfo($page, $name, $name2, $vat_per_unit, $vat_per_unit2, $test_type, $test_type2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderProductsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of OrderProduct resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  int $vat_per_unit  (optional)
     * @param  int[] $vat_per_unit2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsGetCollectionAsyncWithHttpInfo($page = 1, $name = null, $name2 = null, $vat_per_unit = null, $vat_per_unit2 = null, $test_type = null, $test_type2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderProductsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderProduct[]';
        $request = $this->apiApiInternalorderProductsGetCollectionRequest($page, $name, $name2, $vat_per_unit, $vat_per_unit2, $test_type, $test_type2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderProductsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  int $vat_per_unit  (optional)
     * @param  int[] $vat_per_unit2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderProductsGetCollectionRequest($page = 1, $name = null, $name2 = null, $vat_per_unit = null, $vat_per_unit2 = null, $test_type = null, $test_type2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderProductsGetCollection'][0])
    {

















        $resourcePath = '/api-internal/order_products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name2,
            'name[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vat_per_unit,
            'vatPerUnit', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $vat_per_unit2,
            'vatPerUnit[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_type,
            'testType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_type2,
            'testType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_duration_in_minutes,
            'testDurationInMinutes', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_duration_in_minutes2,
            'testDurationInMinutes[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description2,
            'description[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_gross_amount,
            'singleGrossAmount', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_gross_amount2,
            'singleGrossAmount[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderProductsPost
     *
     * Creates a OrderProduct resource.
     *
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The new OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProduct
     */
    public function apiApiInternalorderProductsPost($order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsPost'][0])
    {
        list($response) = $this->apiApiInternalorderProductsPostWithHttpInfo($order_product, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderProductsPostWithHttpInfo
     *
     * Creates a OrderProduct resource.
     *
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The new OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderProductsPostWithHttpInfo($order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsPost'][0])
    {
        $request = $this->apiApiInternalorderProductsPostRequest($order_product, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\OrderProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderProduct' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderProductsPostAsync
     *
     * Creates a OrderProduct resource.
     *
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The new OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsPostAsync($order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsPost'][0])
    {
        return $this->apiApiInternalorderProductsPostAsyncWithHttpInfo($order_product, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderProductsPostAsyncWithHttpInfo
     *
     * Creates a OrderProduct resource.
     *
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The new OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsPostAsyncWithHttpInfo($order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderProduct';
        $request = $this->apiApiInternalorderProductsPostRequest($order_product, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderProductsPost'
     *
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The new OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderProductsPostRequest($order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsPost'][0])
    {

        // verify the required parameter 'order_product' is set
        if ($order_product === null || (is_array($order_product) && count($order_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_product when calling apiApiInternalorderProductsPost'
            );
        }


        $resourcePath = '/api-internal/order_products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_product)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_product));
            } else {
                $httpBody = $order_product;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderProductsUuidGet
     *
     * Retrieves a OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProduct
     */
    public function apiApiInternalorderProductsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidGet'][0])
    {
        list($response) = $this->apiApiInternalorderProductsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderProductsUuidGetWithHttpInfo
     *
     * Retrieves a OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderProductsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidGet'][0])
    {
        $request = $this->apiApiInternalorderProductsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderProduct' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderProductsUuidGetAsync
     *
     * Retrieves a OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidGet'][0])
    {
        return $this->apiApiInternalorderProductsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderProductsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderProduct';
        $request = $this->apiApiInternalorderProductsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderProductsUuidGet'
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderProductsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalorderProductsUuidGet'
            );
        }


        $resourcePath = '/api-internal/order_products/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderProductsUuidPatch
     *
     * Updates the OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The updated OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderProduct
     */
    public function apiApiInternalorderProductsUuidPatch($uuid, $order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalorderProductsUuidPatchWithHttpInfo($uuid, $order_product, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderProductsUuidPatchWithHttpInfo
     *
     * Updates the OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The updated OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderProduct, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderProductsUuidPatchWithHttpInfo($uuid, $order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidPatch'][0])
    {
        $request = $this->apiApiInternalorderProductsUuidPatchRequest($uuid, $order_product, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderProduct' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderProduct' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderProduct', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderProduct';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderProduct',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderProductsUuidPatchAsync
     *
     * Updates the OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The updated OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsUuidPatchAsync($uuid, $order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidPatch'][0])
    {
        return $this->apiApiInternalorderProductsUuidPatchAsyncWithHttpInfo($uuid, $order_product, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderProductsUuidPatchAsyncWithHttpInfo
     *
     * Updates the OrderProduct resource.
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The updated OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderProductsUuidPatchAsyncWithHttpInfo($uuid, $order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderProduct';
        $request = $this->apiApiInternalorderProductsUuidPatchRequest($uuid, $order_product, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderProductsUuidPatch'
     *
     * @param  string $uuid OrderProduct identifier (required)
     * @param  \OpenAPI\Client\Model\OrderProduct $order_product The updated OrderProduct resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderProductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderProductsUuidPatchRequest($uuid, $order_product, string $contentType = self::contentTypes['apiApiInternalorderProductsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalorderProductsUuidPatch'
            );
        }

        // verify the required parameter 'order_product' is set
        if ($order_product === null || (is_array($order_product) && count($order_product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_product when calling apiApiInternalorderProductsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/order_products/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_product)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_product));
            } else {
                $httpBody = $order_product;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderVouchersGetCollection
     *
     * Retrieves the collection of OrderVoucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_code  (optional)
     * @param  string[] $voucher_code2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderVoucher[]
     */
    public function apiApiInternalorderVouchersGetCollection($page = 1, $value = null, $value2 = null, $voucher_code = null, $voucher_code2 = null, $voucher_type = null, $voucher_type2 = null, $voucher_comment = null, $voucher_comment2 = null, $active = null, $active2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderVouchersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalorderVouchersGetCollectionWithHttpInfo($page, $value, $value2, $voucher_code, $voucher_code2, $voucher_type, $voucher_type2, $voucher_comment, $voucher_comment2, $active, $active2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderVouchersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of OrderVoucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_code  (optional)
     * @param  string[] $voucher_code2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderVoucher[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderVouchersGetCollectionWithHttpInfo($page = 1, $value = null, $value2 = null, $voucher_code = null, $voucher_code2 = null, $voucher_type = null, $voucher_type2 = null, $voucher_comment = null, $voucher_comment2 = null, $active = null, $active2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderVouchersGetCollection'][0])
    {
        $request = $this->apiApiInternalorderVouchersGetCollectionRequest($page, $value, $value2, $voucher_code, $voucher_code2, $voucher_type, $voucher_type2, $voucher_comment, $voucher_comment2, $active, $active2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderVoucher[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderVoucher[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderVoucher[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderVoucher[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderVoucher[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderVouchersGetCollectionAsync
     *
     * Retrieves the collection of OrderVoucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_code  (optional)
     * @param  string[] $voucher_code2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersGetCollectionAsync($page = 1, $value = null, $value2 = null, $voucher_code = null, $voucher_code2 = null, $voucher_type = null, $voucher_type2 = null, $voucher_comment = null, $voucher_comment2 = null, $active = null, $active2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderVouchersGetCollection'][0])
    {
        return $this->apiApiInternalorderVouchersGetCollectionAsyncWithHttpInfo($page, $value, $value2, $voucher_code, $voucher_code2, $voucher_type, $voucher_type2, $voucher_comment, $voucher_comment2, $active, $active2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderVouchersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of OrderVoucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_code  (optional)
     * @param  string[] $voucher_code2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersGetCollectionAsyncWithHttpInfo($page = 1, $value = null, $value2 = null, $voucher_code = null, $voucher_code2 = null, $voucher_type = null, $voucher_type2 = null, $voucher_comment = null, $voucher_comment2 = null, $active = null, $active2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderVouchersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderVoucher[]';
        $request = $this->apiApiInternalorderVouchersGetCollectionRequest($page, $value, $value2, $voucher_code, $voucher_code2, $voucher_type, $voucher_type2, $voucher_comment, $voucher_comment2, $active, $active2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderVouchersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_code  (optional)
     * @param  string[] $voucher_code2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderVouchersGetCollectionRequest($page = 1, $value = null, $value2 = null, $voucher_code = null, $voucher_code2 = null, $voucher_type = null, $voucher_type2 = null, $voucher_comment = null, $voucher_comment2 = null, $active = null, $active2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalorderVouchersGetCollection'][0])
    {















        $resourcePath = '/api-internal/order_vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value2,
            'value[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_code,
            'voucherCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_code2,
            'voucherCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_type,
            'voucherType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_type2,
            'voucherType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_comment,
            'voucherComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_comment2,
            'voucherComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active2,
            'active[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderVouchersPost
     *
     * Creates a OrderVoucher resource.
     *
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The new OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderVoucher
     */
    public function apiApiInternalorderVouchersPost($order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersPost'][0])
    {
        list($response) = $this->apiApiInternalorderVouchersPostWithHttpInfo($order_voucher, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderVouchersPostWithHttpInfo
     *
     * Creates a OrderVoucher resource.
     *
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The new OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderVouchersPostWithHttpInfo($order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersPost'][0])
    {
        $request = $this->apiApiInternalorderVouchersPostRequest($order_voucher, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\OrderVoucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderVoucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderVoucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderVoucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderVoucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderVouchersPostAsync
     *
     * Creates a OrderVoucher resource.
     *
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The new OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersPostAsync($order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersPost'][0])
    {
        return $this->apiApiInternalorderVouchersPostAsyncWithHttpInfo($order_voucher, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderVouchersPostAsyncWithHttpInfo
     *
     * Creates a OrderVoucher resource.
     *
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The new OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersPostAsyncWithHttpInfo($order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderVoucher';
        $request = $this->apiApiInternalorderVouchersPostRequest($order_voucher, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderVouchersPost'
     *
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The new OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderVouchersPostRequest($order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersPost'][0])
    {

        // verify the required parameter 'order_voucher' is set
        if ($order_voucher === null || (is_array($order_voucher) && count($order_voucher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_voucher when calling apiApiInternalorderVouchersPost'
            );
        }


        $resourcePath = '/api-internal/order_vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_voucher)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_voucher));
            } else {
                $httpBody = $order_voucher;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderVouchersUuidGet
     *
     * Retrieves a OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderVoucher
     */
    public function apiApiInternalorderVouchersUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidGet'][0])
    {
        list($response) = $this->apiApiInternalorderVouchersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderVouchersUuidGetWithHttpInfo
     *
     * Retrieves a OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderVouchersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidGet'][0])
    {
        $request = $this->apiApiInternalorderVouchersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderVoucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderVoucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderVoucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderVoucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderVoucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderVouchersUuidGetAsync
     *
     * Retrieves a OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidGet'][0])
    {
        return $this->apiApiInternalorderVouchersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderVouchersUuidGetAsyncWithHttpInfo
     *
     * Retrieves a OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderVoucher';
        $request = $this->apiApiInternalorderVouchersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderVouchersUuidGet'
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderVouchersUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalorderVouchersUuidGet'
            );
        }


        $resourcePath = '/api-internal/order_vouchers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalorderVouchersUuidPatch
     *
     * Updates the OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The updated OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\OrderVoucher
     */
    public function apiApiInternalorderVouchersUuidPatch($uuid, $order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalorderVouchersUuidPatchWithHttpInfo($uuid, $order_voucher, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalorderVouchersUuidPatchWithHttpInfo
     *
     * Updates the OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The updated OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\OrderVoucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalorderVouchersUuidPatchWithHttpInfo($uuid, $order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidPatch'][0])
    {
        $request = $this->apiApiInternalorderVouchersUuidPatchRequest($uuid, $order_voucher, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\OrderVoucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\OrderVoucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\OrderVoucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\OrderVoucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\OrderVoucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalorderVouchersUuidPatchAsync
     *
     * Updates the OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The updated OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersUuidPatchAsync($uuid, $order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidPatch'][0])
    {
        return $this->apiApiInternalorderVouchersUuidPatchAsyncWithHttpInfo($uuid, $order_voucher, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalorderVouchersUuidPatchAsyncWithHttpInfo
     *
     * Updates the OrderVoucher resource.
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The updated OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalorderVouchersUuidPatchAsyncWithHttpInfo($uuid, $order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\OrderVoucher';
        $request = $this->apiApiInternalorderVouchersUuidPatchRequest($uuid, $order_voucher, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalorderVouchersUuidPatch'
     *
     * @param  string $uuid OrderVoucher identifier (required)
     * @param  \OpenAPI\Client\Model\OrderVoucher $order_voucher The updated OrderVoucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalorderVouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalorderVouchersUuidPatchRequest($uuid, $order_voucher, string $contentType = self::contentTypes['apiApiInternalorderVouchersUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalorderVouchersUuidPatch'
            );
        }

        // verify the required parameter 'order_voucher' is set
        if ($order_voucher === null || (is_array($order_voucher) && count($order_voucher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order_voucher when calling apiApiInternalorderVouchersUuidPatch'
            );
        }


        $resourcePath = '/api-internal/order_vouchers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order_voucher)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order_voucher));
            } else {
                $httpBody = $order_voucher;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalordersGetCollection
     *
     * Retrieves the collection of Order resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $order_code  (optional)
     * @param  string[] $order_code2  (optional)
     * @param  string $order_status  (optional)
     * @param  string[] $order_status2  (optional)
     * @param  string $payment_status  (optional)
     * @param  string[] $payment_status2  (optional)
     * @param  string $payment_type  (optional)
     * @param  string[] $payment_type2  (optional)
     * @param  string $payment_comment  (optional)
     * @param  string[] $payment_comment2  (optional)
     * @param  string $payment_date  (optional)
     * @param  string $payment_date2  (optional)
     * @param  string $payment_provider  (optional)
     * @param  string[] $payment_provider2  (optional)
     * @param  string $selected_booking_time  (optional)
     * @param  string $selected_booking_time2  (optional)
     * @param  string $invoice_pdf  (optional)
     * @param  string[] $invoice_pdf2  (optional)
     * @param  string $payment_reference  (optional)
     * @param  string[] $payment_reference2  (optional)
     * @param  string $invoice_sent_date  (optional)
     * @param  string $invoice_sent_date2  (optional)
     * @param  bool $is_bto_b  (optional)
     * @param  bool[] $is_bto_b2  (optional)
     * @param  string $booked_by_admin  (optional)
     * @param  string[] $booked_by_admin2  (optional)
     * @param  string $payment_details_changed_by_admin_at  (optional)
     * @param  string $payment_details_changed_by_admin_at2  (optional)
     * @param  string $refund_code  (optional)
     * @param  string[] $refund_code2  (optional)
     * @param  string $refund_time  (optional)
     * @param  string $refund_time2  (optional)
     * @param  string $charge_code  (optional)
     * @param  string[] $charge_code2  (optional)
     * @param  string $patient_booking_information_array  (optional)
     * @param  string[] $patient_booking_information_array2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $invoice_code  (optional)
     * @param  string[] $invoice_code2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order[]
     */
    public function apiApiInternalordersGetCollection($page = 1, $order_code = null, $order_code2 = null, $order_status = null, $order_status2 = null, $payment_status = null, $payment_status2 = null, $payment_type = null, $payment_type2 = null, $payment_comment = null, $payment_comment2 = null, $payment_date = null, $payment_date2 = null, $payment_provider = null, $payment_provider2 = null, $selected_booking_time = null, $selected_booking_time2 = null, $invoice_pdf = null, $invoice_pdf2 = null, $payment_reference = null, $payment_reference2 = null, $invoice_sent_date = null, $invoice_sent_date2 = null, $is_bto_b = null, $is_bto_b2 = null, $booked_by_admin = null, $booked_by_admin2 = null, $payment_details_changed_by_admin_at = null, $payment_details_changed_by_admin_at2 = null, $refund_code = null, $refund_code2 = null, $refund_time = null, $refund_time2 = null, $charge_code = null, $charge_code2 = null, $patient_booking_information_array = null, $patient_booking_information_array2 = null, $created_via = null, $created_via2 = null, $invoice_code = null, $invoice_code2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalordersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalordersGetCollectionWithHttpInfo($page, $order_code, $order_code2, $order_status, $order_status2, $payment_status, $payment_status2, $payment_type, $payment_type2, $payment_comment, $payment_comment2, $payment_date, $payment_date2, $payment_provider, $payment_provider2, $selected_booking_time, $selected_booking_time2, $invoice_pdf, $invoice_pdf2, $payment_reference, $payment_reference2, $invoice_sent_date, $invoice_sent_date2, $is_bto_b, $is_bto_b2, $booked_by_admin, $booked_by_admin2, $payment_details_changed_by_admin_at, $payment_details_changed_by_admin_at2, $refund_code, $refund_code2, $refund_time, $refund_time2, $charge_code, $charge_code2, $patient_booking_information_array, $patient_booking_information_array2, $created_via, $created_via2, $invoice_code, $invoice_code2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalordersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Order resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $order_code  (optional)
     * @param  string[] $order_code2  (optional)
     * @param  string $order_status  (optional)
     * @param  string[] $order_status2  (optional)
     * @param  string $payment_status  (optional)
     * @param  string[] $payment_status2  (optional)
     * @param  string $payment_type  (optional)
     * @param  string[] $payment_type2  (optional)
     * @param  string $payment_comment  (optional)
     * @param  string[] $payment_comment2  (optional)
     * @param  string $payment_date  (optional)
     * @param  string $payment_date2  (optional)
     * @param  string $payment_provider  (optional)
     * @param  string[] $payment_provider2  (optional)
     * @param  string $selected_booking_time  (optional)
     * @param  string $selected_booking_time2  (optional)
     * @param  string $invoice_pdf  (optional)
     * @param  string[] $invoice_pdf2  (optional)
     * @param  string $payment_reference  (optional)
     * @param  string[] $payment_reference2  (optional)
     * @param  string $invoice_sent_date  (optional)
     * @param  string $invoice_sent_date2  (optional)
     * @param  bool $is_bto_b  (optional)
     * @param  bool[] $is_bto_b2  (optional)
     * @param  string $booked_by_admin  (optional)
     * @param  string[] $booked_by_admin2  (optional)
     * @param  string $payment_details_changed_by_admin_at  (optional)
     * @param  string $payment_details_changed_by_admin_at2  (optional)
     * @param  string $refund_code  (optional)
     * @param  string[] $refund_code2  (optional)
     * @param  string $refund_time  (optional)
     * @param  string $refund_time2  (optional)
     * @param  string $charge_code  (optional)
     * @param  string[] $charge_code2  (optional)
     * @param  string $patient_booking_information_array  (optional)
     * @param  string[] $patient_booking_information_array2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $invoice_code  (optional)
     * @param  string[] $invoice_code2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalordersGetCollectionWithHttpInfo($page = 1, $order_code = null, $order_code2 = null, $order_status = null, $order_status2 = null, $payment_status = null, $payment_status2 = null, $payment_type = null, $payment_type2 = null, $payment_comment = null, $payment_comment2 = null, $payment_date = null, $payment_date2 = null, $payment_provider = null, $payment_provider2 = null, $selected_booking_time = null, $selected_booking_time2 = null, $invoice_pdf = null, $invoice_pdf2 = null, $payment_reference = null, $payment_reference2 = null, $invoice_sent_date = null, $invoice_sent_date2 = null, $is_bto_b = null, $is_bto_b2 = null, $booked_by_admin = null, $booked_by_admin2 = null, $payment_details_changed_by_admin_at = null, $payment_details_changed_by_admin_at2 = null, $refund_code = null, $refund_code2 = null, $refund_time = null, $refund_time2 = null, $charge_code = null, $charge_code2 = null, $patient_booking_information_array = null, $patient_booking_information_array2 = null, $created_via = null, $created_via2 = null, $invoice_code = null, $invoice_code2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalordersGetCollection'][0])
    {
        $request = $this->apiApiInternalordersGetCollectionRequest($page, $order_code, $order_code2, $order_status, $order_status2, $payment_status, $payment_status2, $payment_type, $payment_type2, $payment_comment, $payment_comment2, $payment_date, $payment_date2, $payment_provider, $payment_provider2, $selected_booking_time, $selected_booking_time2, $invoice_pdf, $invoice_pdf2, $payment_reference, $payment_reference2, $invoice_sent_date, $invoice_sent_date2, $is_bto_b, $is_bto_b2, $booked_by_admin, $booked_by_admin2, $payment_details_changed_by_admin_at, $payment_details_changed_by_admin_at2, $refund_code, $refund_code2, $refund_time, $refund_time2, $charge_code, $charge_code2, $patient_booking_information_array, $patient_booking_information_array2, $created_via, $created_via2, $invoice_code, $invoice_code2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalordersGetCollectionAsync
     *
     * Retrieves the collection of Order resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $order_code  (optional)
     * @param  string[] $order_code2  (optional)
     * @param  string $order_status  (optional)
     * @param  string[] $order_status2  (optional)
     * @param  string $payment_status  (optional)
     * @param  string[] $payment_status2  (optional)
     * @param  string $payment_type  (optional)
     * @param  string[] $payment_type2  (optional)
     * @param  string $payment_comment  (optional)
     * @param  string[] $payment_comment2  (optional)
     * @param  string $payment_date  (optional)
     * @param  string $payment_date2  (optional)
     * @param  string $payment_provider  (optional)
     * @param  string[] $payment_provider2  (optional)
     * @param  string $selected_booking_time  (optional)
     * @param  string $selected_booking_time2  (optional)
     * @param  string $invoice_pdf  (optional)
     * @param  string[] $invoice_pdf2  (optional)
     * @param  string $payment_reference  (optional)
     * @param  string[] $payment_reference2  (optional)
     * @param  string $invoice_sent_date  (optional)
     * @param  string $invoice_sent_date2  (optional)
     * @param  bool $is_bto_b  (optional)
     * @param  bool[] $is_bto_b2  (optional)
     * @param  string $booked_by_admin  (optional)
     * @param  string[] $booked_by_admin2  (optional)
     * @param  string $payment_details_changed_by_admin_at  (optional)
     * @param  string $payment_details_changed_by_admin_at2  (optional)
     * @param  string $refund_code  (optional)
     * @param  string[] $refund_code2  (optional)
     * @param  string $refund_time  (optional)
     * @param  string $refund_time2  (optional)
     * @param  string $charge_code  (optional)
     * @param  string[] $charge_code2  (optional)
     * @param  string $patient_booking_information_array  (optional)
     * @param  string[] $patient_booking_information_array2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $invoice_code  (optional)
     * @param  string[] $invoice_code2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersGetCollectionAsync($page = 1, $order_code = null, $order_code2 = null, $order_status = null, $order_status2 = null, $payment_status = null, $payment_status2 = null, $payment_type = null, $payment_type2 = null, $payment_comment = null, $payment_comment2 = null, $payment_date = null, $payment_date2 = null, $payment_provider = null, $payment_provider2 = null, $selected_booking_time = null, $selected_booking_time2 = null, $invoice_pdf = null, $invoice_pdf2 = null, $payment_reference = null, $payment_reference2 = null, $invoice_sent_date = null, $invoice_sent_date2 = null, $is_bto_b = null, $is_bto_b2 = null, $booked_by_admin = null, $booked_by_admin2 = null, $payment_details_changed_by_admin_at = null, $payment_details_changed_by_admin_at2 = null, $refund_code = null, $refund_code2 = null, $refund_time = null, $refund_time2 = null, $charge_code = null, $charge_code2 = null, $patient_booking_information_array = null, $patient_booking_information_array2 = null, $created_via = null, $created_via2 = null, $invoice_code = null, $invoice_code2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalordersGetCollection'][0])
    {
        return $this->apiApiInternalordersGetCollectionAsyncWithHttpInfo($page, $order_code, $order_code2, $order_status, $order_status2, $payment_status, $payment_status2, $payment_type, $payment_type2, $payment_comment, $payment_comment2, $payment_date, $payment_date2, $payment_provider, $payment_provider2, $selected_booking_time, $selected_booking_time2, $invoice_pdf, $invoice_pdf2, $payment_reference, $payment_reference2, $invoice_sent_date, $invoice_sent_date2, $is_bto_b, $is_bto_b2, $booked_by_admin, $booked_by_admin2, $payment_details_changed_by_admin_at, $payment_details_changed_by_admin_at2, $refund_code, $refund_code2, $refund_time, $refund_time2, $charge_code, $charge_code2, $patient_booking_information_array, $patient_booking_information_array2, $created_via, $created_via2, $invoice_code, $invoice_code2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalordersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Order resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $order_code  (optional)
     * @param  string[] $order_code2  (optional)
     * @param  string $order_status  (optional)
     * @param  string[] $order_status2  (optional)
     * @param  string $payment_status  (optional)
     * @param  string[] $payment_status2  (optional)
     * @param  string $payment_type  (optional)
     * @param  string[] $payment_type2  (optional)
     * @param  string $payment_comment  (optional)
     * @param  string[] $payment_comment2  (optional)
     * @param  string $payment_date  (optional)
     * @param  string $payment_date2  (optional)
     * @param  string $payment_provider  (optional)
     * @param  string[] $payment_provider2  (optional)
     * @param  string $selected_booking_time  (optional)
     * @param  string $selected_booking_time2  (optional)
     * @param  string $invoice_pdf  (optional)
     * @param  string[] $invoice_pdf2  (optional)
     * @param  string $payment_reference  (optional)
     * @param  string[] $payment_reference2  (optional)
     * @param  string $invoice_sent_date  (optional)
     * @param  string $invoice_sent_date2  (optional)
     * @param  bool $is_bto_b  (optional)
     * @param  bool[] $is_bto_b2  (optional)
     * @param  string $booked_by_admin  (optional)
     * @param  string[] $booked_by_admin2  (optional)
     * @param  string $payment_details_changed_by_admin_at  (optional)
     * @param  string $payment_details_changed_by_admin_at2  (optional)
     * @param  string $refund_code  (optional)
     * @param  string[] $refund_code2  (optional)
     * @param  string $refund_time  (optional)
     * @param  string $refund_time2  (optional)
     * @param  string $charge_code  (optional)
     * @param  string[] $charge_code2  (optional)
     * @param  string $patient_booking_information_array  (optional)
     * @param  string[] $patient_booking_information_array2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $invoice_code  (optional)
     * @param  string[] $invoice_code2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersGetCollectionAsyncWithHttpInfo($page = 1, $order_code = null, $order_code2 = null, $order_status = null, $order_status2 = null, $payment_status = null, $payment_status2 = null, $payment_type = null, $payment_type2 = null, $payment_comment = null, $payment_comment2 = null, $payment_date = null, $payment_date2 = null, $payment_provider = null, $payment_provider2 = null, $selected_booking_time = null, $selected_booking_time2 = null, $invoice_pdf = null, $invoice_pdf2 = null, $payment_reference = null, $payment_reference2 = null, $invoice_sent_date = null, $invoice_sent_date2 = null, $is_bto_b = null, $is_bto_b2 = null, $booked_by_admin = null, $booked_by_admin2 = null, $payment_details_changed_by_admin_at = null, $payment_details_changed_by_admin_at2 = null, $refund_code = null, $refund_code2 = null, $refund_time = null, $refund_time2 = null, $charge_code = null, $charge_code2 = null, $patient_booking_information_array = null, $patient_booking_information_array2 = null, $created_via = null, $created_via2 = null, $invoice_code = null, $invoice_code2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalordersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order[]';
        $request = $this->apiApiInternalordersGetCollectionRequest($page, $order_code, $order_code2, $order_status, $order_status2, $payment_status, $payment_status2, $payment_type, $payment_type2, $payment_comment, $payment_comment2, $payment_date, $payment_date2, $payment_provider, $payment_provider2, $selected_booking_time, $selected_booking_time2, $invoice_pdf, $invoice_pdf2, $payment_reference, $payment_reference2, $invoice_sent_date, $invoice_sent_date2, $is_bto_b, $is_bto_b2, $booked_by_admin, $booked_by_admin2, $payment_details_changed_by_admin_at, $payment_details_changed_by_admin_at2, $refund_code, $refund_code2, $refund_time, $refund_time2, $charge_code, $charge_code2, $patient_booking_information_array, $patient_booking_information_array2, $created_via, $created_via2, $invoice_code, $invoice_code2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalordersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $order_code  (optional)
     * @param  string[] $order_code2  (optional)
     * @param  string $order_status  (optional)
     * @param  string[] $order_status2  (optional)
     * @param  string $payment_status  (optional)
     * @param  string[] $payment_status2  (optional)
     * @param  string $payment_type  (optional)
     * @param  string[] $payment_type2  (optional)
     * @param  string $payment_comment  (optional)
     * @param  string[] $payment_comment2  (optional)
     * @param  string $payment_date  (optional)
     * @param  string $payment_date2  (optional)
     * @param  string $payment_provider  (optional)
     * @param  string[] $payment_provider2  (optional)
     * @param  string $selected_booking_time  (optional)
     * @param  string $selected_booking_time2  (optional)
     * @param  string $invoice_pdf  (optional)
     * @param  string[] $invoice_pdf2  (optional)
     * @param  string $payment_reference  (optional)
     * @param  string[] $payment_reference2  (optional)
     * @param  string $invoice_sent_date  (optional)
     * @param  string $invoice_sent_date2  (optional)
     * @param  bool $is_bto_b  (optional)
     * @param  bool[] $is_bto_b2  (optional)
     * @param  string $booked_by_admin  (optional)
     * @param  string[] $booked_by_admin2  (optional)
     * @param  string $payment_details_changed_by_admin_at  (optional)
     * @param  string $payment_details_changed_by_admin_at2  (optional)
     * @param  string $refund_code  (optional)
     * @param  string[] $refund_code2  (optional)
     * @param  string $refund_time  (optional)
     * @param  string $refund_time2  (optional)
     * @param  string $charge_code  (optional)
     * @param  string[] $charge_code2  (optional)
     * @param  string $patient_booking_information_array  (optional)
     * @param  string[] $patient_booking_information_array2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $invoice_code  (optional)
     * @param  string[] $invoice_code2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalordersGetCollectionRequest($page = 1, $order_code = null, $order_code2 = null, $order_status = null, $order_status2 = null, $payment_status = null, $payment_status2 = null, $payment_type = null, $payment_type2 = null, $payment_comment = null, $payment_comment2 = null, $payment_date = null, $payment_date2 = null, $payment_provider = null, $payment_provider2 = null, $selected_booking_time = null, $selected_booking_time2 = null, $invoice_pdf = null, $invoice_pdf2 = null, $payment_reference = null, $payment_reference2 = null, $invoice_sent_date = null, $invoice_sent_date2 = null, $is_bto_b = null, $is_bto_b2 = null, $booked_by_admin = null, $booked_by_admin2 = null, $payment_details_changed_by_admin_at = null, $payment_details_changed_by_admin_at2 = null, $refund_code = null, $refund_code2 = null, $refund_time = null, $refund_time2 = null, $charge_code = null, $charge_code2 = null, $patient_booking_information_array = null, $patient_booking_information_array2 = null, $created_via = null, $created_via2 = null, $invoice_code = null, $invoice_code2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalordersGetCollection'][0])
    {

















































        $resourcePath = '/api-internal/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_code,
            'orderCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_code2,
            'orderCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_status,
            'orderStatus', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_status2,
            'orderStatus[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_status,
            'paymentStatus', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_status2,
            'paymentStatus[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_type,
            'paymentType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_type2,
            'paymentType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_comment,
            'paymentComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_comment2,
            'paymentComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_date,
            'paymentDate', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_date2,
            'paymentDate[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_provider,
            'paymentProvider', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_provider2,
            'paymentProvider[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $selected_booking_time,
            'selectedBookingTime', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $selected_booking_time2,
            'selectedBookingTime[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_pdf,
            'invoicePdf', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_pdf2,
            'invoicePdf[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_reference,
            'paymentReference', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_reference2,
            'paymentReference[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_sent_date,
            'invoiceSentDate', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_sent_date2,
            'invoiceSentDate[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_bto_b,
            'isBToB', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_bto_b2,
            'isBToB[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $booked_by_admin,
            'bookedByAdmin', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $booked_by_admin2,
            'bookedByAdmin[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_details_changed_by_admin_at,
            'paymentDetailsChangedByAdminAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $payment_details_changed_by_admin_at2,
            'paymentDetailsChangedByAdminAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $refund_code,
            'refundCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $refund_code2,
            'refundCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $refund_time,
            'refundTime', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $refund_time2,
            'refundTime[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $charge_code,
            'chargeCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $charge_code2,
            'chargeCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_booking_information_array,
            'patientBookingInformationArray', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_booking_information_array2,
            'patientBookingInformationArray[]', // param base name
            'array', // openApiType
            'deepObject', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_via,
            'createdVia', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_via2,
            'createdVia[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_code,
            'invoiceCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $invoice_code2,
            'invoiceCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalordersPost
     *
     * Creates a Order resource.
     *
     * @param  \OpenAPI\Client\Model\Order $order The new Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function apiApiInternalordersPost($order, string $contentType = self::contentTypes['apiApiInternalordersPost'][0])
    {
        list($response) = $this->apiApiInternalordersPostWithHttpInfo($order, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalordersPostWithHttpInfo
     *
     * Creates a Order resource.
     *
     * @param  \OpenAPI\Client\Model\Order $order The new Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalordersPostWithHttpInfo($order, string $contentType = self::contentTypes['apiApiInternalordersPost'][0])
    {
        $request = $this->apiApiInternalordersPostRequest($order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalordersPostAsync
     *
     * Creates a Order resource.
     *
     * @param  \OpenAPI\Client\Model\Order $order The new Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersPostAsync($order, string $contentType = self::contentTypes['apiApiInternalordersPost'][0])
    {
        return $this->apiApiInternalordersPostAsyncWithHttpInfo($order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalordersPostAsyncWithHttpInfo
     *
     * Creates a Order resource.
     *
     * @param  \OpenAPI\Client\Model\Order $order The new Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersPostAsyncWithHttpInfo($order, string $contentType = self::contentTypes['apiApiInternalordersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->apiApiInternalordersPostRequest($order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalordersPost'
     *
     * @param  \OpenAPI\Client\Model\Order $order The new Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalordersPostRequest($order, string $contentType = self::contentTypes['apiApiInternalordersPost'][0])
    {

        // verify the required parameter 'order' is set
        if ($order === null || (is_array($order) && count($order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order when calling apiApiInternalordersPost'
            );
        }


        $resourcePath = '/api-internal/orders';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order));
            } else {
                $httpBody = $order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalordersUuidGet
     *
     * Retrieves a Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function apiApiInternalordersUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalordersUuidGet'][0])
    {
        list($response) = $this->apiApiInternalordersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalordersUuidGetWithHttpInfo
     *
     * Retrieves a Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalordersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalordersUuidGet'][0])
    {
        $request = $this->apiApiInternalordersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalordersUuidGetAsync
     *
     * Retrieves a Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalordersUuidGet'][0])
    {
        return $this->apiApiInternalordersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalordersUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalordersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->apiApiInternalordersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalordersUuidGet'
     *
     * @param  string $uuid Order identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalordersUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalordersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalordersUuidGet'
            );
        }


        $resourcePath = '/api-internal/orders/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalordersUuidPatch
     *
     * Updates the Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  \OpenAPI\Client\Model\Order $order The updated Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Order
     */
    public function apiApiInternalordersUuidPatch($uuid, $order, string $contentType = self::contentTypes['apiApiInternalordersUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalordersUuidPatchWithHttpInfo($uuid, $order, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalordersUuidPatchWithHttpInfo
     *
     * Updates the Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  \OpenAPI\Client\Model\Order $order The updated Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Order, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalordersUuidPatchWithHttpInfo($uuid, $order, string $contentType = self::contentTypes['apiApiInternalordersUuidPatch'][0])
    {
        $request = $this->apiApiInternalordersUuidPatchRequest($uuid, $order, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Order' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Order' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Order', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Order';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Order',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalordersUuidPatchAsync
     *
     * Updates the Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  \OpenAPI\Client\Model\Order $order The updated Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersUuidPatchAsync($uuid, $order, string $contentType = self::contentTypes['apiApiInternalordersUuidPatch'][0])
    {
        return $this->apiApiInternalordersUuidPatchAsyncWithHttpInfo($uuid, $order, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalordersUuidPatchAsyncWithHttpInfo
     *
     * Updates the Order resource.
     *
     * @param  string $uuid Order identifier (required)
     * @param  \OpenAPI\Client\Model\Order $order The updated Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalordersUuidPatchAsyncWithHttpInfo($uuid, $order, string $contentType = self::contentTypes['apiApiInternalordersUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Order';
        $request = $this->apiApiInternalordersUuidPatchRequest($uuid, $order, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalordersUuidPatch'
     *
     * @param  string $uuid Order identifier (required)
     * @param  \OpenAPI\Client\Model\Order $order The updated Order resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalordersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalordersUuidPatchRequest($uuid, $order, string $contentType = self::contentTypes['apiApiInternalordersUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalordersUuidPatch'
            );
        }

        // verify the required parameter 'order' is set
        if ($order === null || (is_array($order) && count($order) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $order when calling apiApiInternalordersUuidPatch'
            );
        }


        $resourcePath = '/api-internal/orders/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($order)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($order));
            } else {
                $httpBody = $order;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientEventsGetCollection
     *
     * Retrieves the collection of PatientEvent resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $patient_index  (optional)
     * @param  int[] $patient_index2  (optional)
     * @param  string $test_code  (optional)
     * @param  string[] $test_code2  (optional)
     * @param  string $appointment_time  (optional)
     * @param  string $appointment_time2  (optional)
     * @param  string $comment  (optional)
     * @param  string[] $comment2  (optional)
     * @param  string $doctor_comment  (optional)
     * @param  string[] $doctor_comment2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $test_result_pdf  (optional)
     * @param  string[] $test_result_pdf2  (optional)
     * @param  string $cabin_number  (optional)
     * @param  string[] $cabin_number2  (optional)
     * @param  string $internal_code  (optional)
     * @param  string[] $internal_code2  (optional)
     * @param  string $test_password  (optional)
     * @param  string[] $test_password2  (optional)
     * @param  int $number_of_access_denied_events  (optional)
     * @param  int[] $number_of_access_denied_events2  (optional)
     * @param  bool $is_label_printed  (optional)
     * @param  bool[] $is_label_printed2  (optional)
     * @param  string $reminder_sent_at  (optional)
     * @param  string $reminder_sent_at2  (optional)
     * @param  string $available_for_free_test_confirmed_at  (optional)
     * @param  string $available_for_free_test_confirmed_at2  (optional)
     * @param  string $test_paid_confirmed_at  (optional)
     * @param  string $test_paid_confirmed_at2  (optional)
     * @param  string $order_uuid  (optional)
     * @param  string[] $order_uuid2  (optional)
     * @param  string $sent_result_date  (optional)
     * @param  string $sent_result_date2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $updated_via  (optional)
     * @param  string[] $updated_via2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $validated_at  (optional)
     * @param  string $validated_at2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $location_name  (optional)
     * @param  string[] $location_name2  (optional)
     * @param  string $results  (optional)
     * @param  string[] $results2  (optional)
     * @param  string $decision  (optional)
     * @param  string[] $decision2  (optional)
     * @param  string $test_start_time  (optional)
     * @param  string $test_start_time2  (optional)
     * @param  string $test_end_time  (optional)
     * @param  string $test_end_time2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientEvent[]
     */
    public function apiApiInternalpatientEventsGetCollection($page = 1, $patient_index = null, $patient_index2 = null, $test_code = null, $test_code2 = null, $appointment_time = null, $appointment_time2 = null, $comment = null, $comment2 = null, $doctor_comment = null, $doctor_comment2 = null, $loinc = null, $loinc2 = null, $test_result_pdf = null, $test_result_pdf2 = null, $cabin_number = null, $cabin_number2 = null, $internal_code = null, $internal_code2 = null, $test_password = null, $test_password2 = null, $number_of_access_denied_events = null, $number_of_access_denied_events2 = null, $is_label_printed = null, $is_label_printed2 = null, $reminder_sent_at = null, $reminder_sent_at2 = null, $available_for_free_test_confirmed_at = null, $available_for_free_test_confirmed_at2 = null, $test_paid_confirmed_at = null, $test_paid_confirmed_at2 = null, $order_uuid = null, $order_uuid2 = null, $sent_result_date = null, $sent_result_date2 = null, $loinc_display = null, $loinc_display2 = null, $updated_via = null, $updated_via2 = null, $created_via = null, $created_via2 = null, $validated_at = null, $validated_at2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $location_name = null, $location_name2 = null, $results = null, $results2 = null, $decision = null, $decision2 = null, $test_start_time = null, $test_start_time2 = null, $test_end_time = null, $test_end_time2 = null, $status = null, $status2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalpatientEventsGetCollection'][0])
    {
        list($response) = $this->apiApiInternalpatientEventsGetCollectionWithHttpInfo($page, $patient_index, $patient_index2, $test_code, $test_code2, $appointment_time, $appointment_time2, $comment, $comment2, $doctor_comment, $doctor_comment2, $loinc, $loinc2, $test_result_pdf, $test_result_pdf2, $cabin_number, $cabin_number2, $internal_code, $internal_code2, $test_password, $test_password2, $number_of_access_denied_events, $number_of_access_denied_events2, $is_label_printed, $is_label_printed2, $reminder_sent_at, $reminder_sent_at2, $available_for_free_test_confirmed_at, $available_for_free_test_confirmed_at2, $test_paid_confirmed_at, $test_paid_confirmed_at2, $order_uuid, $order_uuid2, $sent_result_date, $sent_result_date2, $loinc_display, $loinc_display2, $updated_via, $updated_via2, $created_via, $created_via2, $validated_at, $validated_at2, $test_workflow_type, $test_workflow_type2, $location_name, $location_name2, $results, $results2, $decision, $decision2, $test_start_time, $test_start_time2, $test_end_time, $test_end_time2, $status, $status2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientEventsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of PatientEvent resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $patient_index  (optional)
     * @param  int[] $patient_index2  (optional)
     * @param  string $test_code  (optional)
     * @param  string[] $test_code2  (optional)
     * @param  string $appointment_time  (optional)
     * @param  string $appointment_time2  (optional)
     * @param  string $comment  (optional)
     * @param  string[] $comment2  (optional)
     * @param  string $doctor_comment  (optional)
     * @param  string[] $doctor_comment2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $test_result_pdf  (optional)
     * @param  string[] $test_result_pdf2  (optional)
     * @param  string $cabin_number  (optional)
     * @param  string[] $cabin_number2  (optional)
     * @param  string $internal_code  (optional)
     * @param  string[] $internal_code2  (optional)
     * @param  string $test_password  (optional)
     * @param  string[] $test_password2  (optional)
     * @param  int $number_of_access_denied_events  (optional)
     * @param  int[] $number_of_access_denied_events2  (optional)
     * @param  bool $is_label_printed  (optional)
     * @param  bool[] $is_label_printed2  (optional)
     * @param  string $reminder_sent_at  (optional)
     * @param  string $reminder_sent_at2  (optional)
     * @param  string $available_for_free_test_confirmed_at  (optional)
     * @param  string $available_for_free_test_confirmed_at2  (optional)
     * @param  string $test_paid_confirmed_at  (optional)
     * @param  string $test_paid_confirmed_at2  (optional)
     * @param  string $order_uuid  (optional)
     * @param  string[] $order_uuid2  (optional)
     * @param  string $sent_result_date  (optional)
     * @param  string $sent_result_date2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $updated_via  (optional)
     * @param  string[] $updated_via2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $validated_at  (optional)
     * @param  string $validated_at2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $location_name  (optional)
     * @param  string[] $location_name2  (optional)
     * @param  string $results  (optional)
     * @param  string[] $results2  (optional)
     * @param  string $decision  (optional)
     * @param  string[] $decision2  (optional)
     * @param  string $test_start_time  (optional)
     * @param  string $test_start_time2  (optional)
     * @param  string $test_end_time  (optional)
     * @param  string $test_end_time2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientEvent[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientEventsGetCollectionWithHttpInfo($page = 1, $patient_index = null, $patient_index2 = null, $test_code = null, $test_code2 = null, $appointment_time = null, $appointment_time2 = null, $comment = null, $comment2 = null, $doctor_comment = null, $doctor_comment2 = null, $loinc = null, $loinc2 = null, $test_result_pdf = null, $test_result_pdf2 = null, $cabin_number = null, $cabin_number2 = null, $internal_code = null, $internal_code2 = null, $test_password = null, $test_password2 = null, $number_of_access_denied_events = null, $number_of_access_denied_events2 = null, $is_label_printed = null, $is_label_printed2 = null, $reminder_sent_at = null, $reminder_sent_at2 = null, $available_for_free_test_confirmed_at = null, $available_for_free_test_confirmed_at2 = null, $test_paid_confirmed_at = null, $test_paid_confirmed_at2 = null, $order_uuid = null, $order_uuid2 = null, $sent_result_date = null, $sent_result_date2 = null, $loinc_display = null, $loinc_display2 = null, $updated_via = null, $updated_via2 = null, $created_via = null, $created_via2 = null, $validated_at = null, $validated_at2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $location_name = null, $location_name2 = null, $results = null, $results2 = null, $decision = null, $decision2 = null, $test_start_time = null, $test_start_time2 = null, $test_end_time = null, $test_end_time2 = null, $status = null, $status2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalpatientEventsGetCollection'][0])
    {
        $request = $this->apiApiInternalpatientEventsGetCollectionRequest($page, $patient_index, $patient_index2, $test_code, $test_code2, $appointment_time, $appointment_time2, $comment, $comment2, $doctor_comment, $doctor_comment2, $loinc, $loinc2, $test_result_pdf, $test_result_pdf2, $cabin_number, $cabin_number2, $internal_code, $internal_code2, $test_password, $test_password2, $number_of_access_denied_events, $number_of_access_denied_events2, $is_label_printed, $is_label_printed2, $reminder_sent_at, $reminder_sent_at2, $available_for_free_test_confirmed_at, $available_for_free_test_confirmed_at2, $test_paid_confirmed_at, $test_paid_confirmed_at2, $order_uuid, $order_uuid2, $sent_result_date, $sent_result_date2, $loinc_display, $loinc_display2, $updated_via, $updated_via2, $created_via, $created_via2, $validated_at, $validated_at2, $test_workflow_type, $test_workflow_type2, $location_name, $location_name2, $results, $results2, $decision, $decision2, $test_start_time, $test_start_time2, $test_end_time, $test_end_time2, $status, $status2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientEvent[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientEvent[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientEvent[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientEvent[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientEvent[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientEventsGetCollectionAsync
     *
     * Retrieves the collection of PatientEvent resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $patient_index  (optional)
     * @param  int[] $patient_index2  (optional)
     * @param  string $test_code  (optional)
     * @param  string[] $test_code2  (optional)
     * @param  string $appointment_time  (optional)
     * @param  string $appointment_time2  (optional)
     * @param  string $comment  (optional)
     * @param  string[] $comment2  (optional)
     * @param  string $doctor_comment  (optional)
     * @param  string[] $doctor_comment2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $test_result_pdf  (optional)
     * @param  string[] $test_result_pdf2  (optional)
     * @param  string $cabin_number  (optional)
     * @param  string[] $cabin_number2  (optional)
     * @param  string $internal_code  (optional)
     * @param  string[] $internal_code2  (optional)
     * @param  string $test_password  (optional)
     * @param  string[] $test_password2  (optional)
     * @param  int $number_of_access_denied_events  (optional)
     * @param  int[] $number_of_access_denied_events2  (optional)
     * @param  bool $is_label_printed  (optional)
     * @param  bool[] $is_label_printed2  (optional)
     * @param  string $reminder_sent_at  (optional)
     * @param  string $reminder_sent_at2  (optional)
     * @param  string $available_for_free_test_confirmed_at  (optional)
     * @param  string $available_for_free_test_confirmed_at2  (optional)
     * @param  string $test_paid_confirmed_at  (optional)
     * @param  string $test_paid_confirmed_at2  (optional)
     * @param  string $order_uuid  (optional)
     * @param  string[] $order_uuid2  (optional)
     * @param  string $sent_result_date  (optional)
     * @param  string $sent_result_date2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $updated_via  (optional)
     * @param  string[] $updated_via2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $validated_at  (optional)
     * @param  string $validated_at2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $location_name  (optional)
     * @param  string[] $location_name2  (optional)
     * @param  string $results  (optional)
     * @param  string[] $results2  (optional)
     * @param  string $decision  (optional)
     * @param  string[] $decision2  (optional)
     * @param  string $test_start_time  (optional)
     * @param  string $test_start_time2  (optional)
     * @param  string $test_end_time  (optional)
     * @param  string $test_end_time2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsGetCollectionAsync($page = 1, $patient_index = null, $patient_index2 = null, $test_code = null, $test_code2 = null, $appointment_time = null, $appointment_time2 = null, $comment = null, $comment2 = null, $doctor_comment = null, $doctor_comment2 = null, $loinc = null, $loinc2 = null, $test_result_pdf = null, $test_result_pdf2 = null, $cabin_number = null, $cabin_number2 = null, $internal_code = null, $internal_code2 = null, $test_password = null, $test_password2 = null, $number_of_access_denied_events = null, $number_of_access_denied_events2 = null, $is_label_printed = null, $is_label_printed2 = null, $reminder_sent_at = null, $reminder_sent_at2 = null, $available_for_free_test_confirmed_at = null, $available_for_free_test_confirmed_at2 = null, $test_paid_confirmed_at = null, $test_paid_confirmed_at2 = null, $order_uuid = null, $order_uuid2 = null, $sent_result_date = null, $sent_result_date2 = null, $loinc_display = null, $loinc_display2 = null, $updated_via = null, $updated_via2 = null, $created_via = null, $created_via2 = null, $validated_at = null, $validated_at2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $location_name = null, $location_name2 = null, $results = null, $results2 = null, $decision = null, $decision2 = null, $test_start_time = null, $test_start_time2 = null, $test_end_time = null, $test_end_time2 = null, $status = null, $status2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalpatientEventsGetCollection'][0])
    {
        return $this->apiApiInternalpatientEventsGetCollectionAsyncWithHttpInfo($page, $patient_index, $patient_index2, $test_code, $test_code2, $appointment_time, $appointment_time2, $comment, $comment2, $doctor_comment, $doctor_comment2, $loinc, $loinc2, $test_result_pdf, $test_result_pdf2, $cabin_number, $cabin_number2, $internal_code, $internal_code2, $test_password, $test_password2, $number_of_access_denied_events, $number_of_access_denied_events2, $is_label_printed, $is_label_printed2, $reminder_sent_at, $reminder_sent_at2, $available_for_free_test_confirmed_at, $available_for_free_test_confirmed_at2, $test_paid_confirmed_at, $test_paid_confirmed_at2, $order_uuid, $order_uuid2, $sent_result_date, $sent_result_date2, $loinc_display, $loinc_display2, $updated_via, $updated_via2, $created_via, $created_via2, $validated_at, $validated_at2, $test_workflow_type, $test_workflow_type2, $location_name, $location_name2, $results, $results2, $decision, $decision2, $test_start_time, $test_start_time2, $test_end_time, $test_end_time2, $status, $status2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientEventsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of PatientEvent resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $patient_index  (optional)
     * @param  int[] $patient_index2  (optional)
     * @param  string $test_code  (optional)
     * @param  string[] $test_code2  (optional)
     * @param  string $appointment_time  (optional)
     * @param  string $appointment_time2  (optional)
     * @param  string $comment  (optional)
     * @param  string[] $comment2  (optional)
     * @param  string $doctor_comment  (optional)
     * @param  string[] $doctor_comment2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $test_result_pdf  (optional)
     * @param  string[] $test_result_pdf2  (optional)
     * @param  string $cabin_number  (optional)
     * @param  string[] $cabin_number2  (optional)
     * @param  string $internal_code  (optional)
     * @param  string[] $internal_code2  (optional)
     * @param  string $test_password  (optional)
     * @param  string[] $test_password2  (optional)
     * @param  int $number_of_access_denied_events  (optional)
     * @param  int[] $number_of_access_denied_events2  (optional)
     * @param  bool $is_label_printed  (optional)
     * @param  bool[] $is_label_printed2  (optional)
     * @param  string $reminder_sent_at  (optional)
     * @param  string $reminder_sent_at2  (optional)
     * @param  string $available_for_free_test_confirmed_at  (optional)
     * @param  string $available_for_free_test_confirmed_at2  (optional)
     * @param  string $test_paid_confirmed_at  (optional)
     * @param  string $test_paid_confirmed_at2  (optional)
     * @param  string $order_uuid  (optional)
     * @param  string[] $order_uuid2  (optional)
     * @param  string $sent_result_date  (optional)
     * @param  string $sent_result_date2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $updated_via  (optional)
     * @param  string[] $updated_via2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $validated_at  (optional)
     * @param  string $validated_at2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $location_name  (optional)
     * @param  string[] $location_name2  (optional)
     * @param  string $results  (optional)
     * @param  string[] $results2  (optional)
     * @param  string $decision  (optional)
     * @param  string[] $decision2  (optional)
     * @param  string $test_start_time  (optional)
     * @param  string $test_start_time2  (optional)
     * @param  string $test_end_time  (optional)
     * @param  string $test_end_time2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsGetCollectionAsyncWithHttpInfo($page = 1, $patient_index = null, $patient_index2 = null, $test_code = null, $test_code2 = null, $appointment_time = null, $appointment_time2 = null, $comment = null, $comment2 = null, $doctor_comment = null, $doctor_comment2 = null, $loinc = null, $loinc2 = null, $test_result_pdf = null, $test_result_pdf2 = null, $cabin_number = null, $cabin_number2 = null, $internal_code = null, $internal_code2 = null, $test_password = null, $test_password2 = null, $number_of_access_denied_events = null, $number_of_access_denied_events2 = null, $is_label_printed = null, $is_label_printed2 = null, $reminder_sent_at = null, $reminder_sent_at2 = null, $available_for_free_test_confirmed_at = null, $available_for_free_test_confirmed_at2 = null, $test_paid_confirmed_at = null, $test_paid_confirmed_at2 = null, $order_uuid = null, $order_uuid2 = null, $sent_result_date = null, $sent_result_date2 = null, $loinc_display = null, $loinc_display2 = null, $updated_via = null, $updated_via2 = null, $created_via = null, $created_via2 = null, $validated_at = null, $validated_at2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $location_name = null, $location_name2 = null, $results = null, $results2 = null, $decision = null, $decision2 = null, $test_start_time = null, $test_start_time2 = null, $test_end_time = null, $test_end_time2 = null, $status = null, $status2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalpatientEventsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientEvent[]';
        $request = $this->apiApiInternalpatientEventsGetCollectionRequest($page, $patient_index, $patient_index2, $test_code, $test_code2, $appointment_time, $appointment_time2, $comment, $comment2, $doctor_comment, $doctor_comment2, $loinc, $loinc2, $test_result_pdf, $test_result_pdf2, $cabin_number, $cabin_number2, $internal_code, $internal_code2, $test_password, $test_password2, $number_of_access_denied_events, $number_of_access_denied_events2, $is_label_printed, $is_label_printed2, $reminder_sent_at, $reminder_sent_at2, $available_for_free_test_confirmed_at, $available_for_free_test_confirmed_at2, $test_paid_confirmed_at, $test_paid_confirmed_at2, $order_uuid, $order_uuid2, $sent_result_date, $sent_result_date2, $loinc_display, $loinc_display2, $updated_via, $updated_via2, $created_via, $created_via2, $validated_at, $validated_at2, $test_workflow_type, $test_workflow_type2, $location_name, $location_name2, $results, $results2, $decision, $decision2, $test_start_time, $test_start_time2, $test_end_time, $test_end_time2, $status, $status2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientEventsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  int $patient_index  (optional)
     * @param  int[] $patient_index2  (optional)
     * @param  string $test_code  (optional)
     * @param  string[] $test_code2  (optional)
     * @param  string $appointment_time  (optional)
     * @param  string $appointment_time2  (optional)
     * @param  string $comment  (optional)
     * @param  string[] $comment2  (optional)
     * @param  string $doctor_comment  (optional)
     * @param  string[] $doctor_comment2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $test_result_pdf  (optional)
     * @param  string[] $test_result_pdf2  (optional)
     * @param  string $cabin_number  (optional)
     * @param  string[] $cabin_number2  (optional)
     * @param  string $internal_code  (optional)
     * @param  string[] $internal_code2  (optional)
     * @param  string $test_password  (optional)
     * @param  string[] $test_password2  (optional)
     * @param  int $number_of_access_denied_events  (optional)
     * @param  int[] $number_of_access_denied_events2  (optional)
     * @param  bool $is_label_printed  (optional)
     * @param  bool[] $is_label_printed2  (optional)
     * @param  string $reminder_sent_at  (optional)
     * @param  string $reminder_sent_at2  (optional)
     * @param  string $available_for_free_test_confirmed_at  (optional)
     * @param  string $available_for_free_test_confirmed_at2  (optional)
     * @param  string $test_paid_confirmed_at  (optional)
     * @param  string $test_paid_confirmed_at2  (optional)
     * @param  string $order_uuid  (optional)
     * @param  string[] $order_uuid2  (optional)
     * @param  string $sent_result_date  (optional)
     * @param  string $sent_result_date2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $updated_via  (optional)
     * @param  string[] $updated_via2  (optional)
     * @param  string $created_via  (optional)
     * @param  string[] $created_via2  (optional)
     * @param  string $validated_at  (optional)
     * @param  string $validated_at2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $location_name  (optional)
     * @param  string[] $location_name2  (optional)
     * @param  string $results  (optional)
     * @param  string[] $results2  (optional)
     * @param  string $decision  (optional)
     * @param  string[] $decision2  (optional)
     * @param  string $test_start_time  (optional)
     * @param  string $test_start_time2  (optional)
     * @param  string $test_end_time  (optional)
     * @param  string $test_end_time2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientEventsGetCollectionRequest($page = 1, $patient_index = null, $patient_index2 = null, $test_code = null, $test_code2 = null, $appointment_time = null, $appointment_time2 = null, $comment = null, $comment2 = null, $doctor_comment = null, $doctor_comment2 = null, $loinc = null, $loinc2 = null, $test_result_pdf = null, $test_result_pdf2 = null, $cabin_number = null, $cabin_number2 = null, $internal_code = null, $internal_code2 = null, $test_password = null, $test_password2 = null, $number_of_access_denied_events = null, $number_of_access_denied_events2 = null, $is_label_printed = null, $is_label_printed2 = null, $reminder_sent_at = null, $reminder_sent_at2 = null, $available_for_free_test_confirmed_at = null, $available_for_free_test_confirmed_at2 = null, $test_paid_confirmed_at = null, $test_paid_confirmed_at2 = null, $order_uuid = null, $order_uuid2 = null, $sent_result_date = null, $sent_result_date2 = null, $loinc_display = null, $loinc_display2 = null, $updated_via = null, $updated_via2 = null, $created_via = null, $created_via2 = null, $validated_at = null, $validated_at2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $location_name = null, $location_name2 = null, $results = null, $results2 = null, $decision = null, $decision2 = null, $test_start_time = null, $test_start_time2 = null, $test_end_time = null, $test_end_time2 = null, $status = null, $status2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalpatientEventsGetCollection'][0])
    {



































































































        $resourcePath = '/api-internal/patient_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_index,
            'patientIndex', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_index2,
            'patientIndex[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_code,
            'testCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_code2,
            'testCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $appointment_time,
            'appointmentTime', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $appointment_time2,
            'appointmentTime[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment,
            'comment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $comment2,
            'comment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doctor_comment,
            'doctorComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doctor_comment2,
            'doctorComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc,
            'loinc', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc2,
            'loinc[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_result_pdf,
            'testResultPdf', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_result_pdf2,
            'testResultPdf[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cabin_number,
            'cabinNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $cabin_number2,
            'cabinNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code,
            'internalCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code2,
            'internalCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_password,
            'testPassword', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_password2,
            'testPassword[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_of_access_denied_events,
            'numberOfAccessDeniedEvents', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_of_access_denied_events2,
            'numberOfAccessDeniedEvents[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_label_printed,
            'isLabelPrinted', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_label_printed2,
            'isLabelPrinted[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reminder_sent_at,
            'reminderSentAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reminder_sent_at2,
            'reminderSentAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_for_free_test_confirmed_at,
            'availableForFreeTestConfirmedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_for_free_test_confirmed_at2,
            'availableForFreeTestConfirmedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_paid_confirmed_at,
            'testPaidConfirmedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_paid_confirmed_at2,
            'testPaidConfirmedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_uuid,
            'orderUuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $order_uuid2,
            'orderUuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sent_result_date,
            'sentResultDate', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $sent_result_date2,
            'sentResultDate[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc_display,
            'loincDisplay', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc_display2,
            'loincDisplay[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_via,
            'updatedVia', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_via2,
            'updatedVia[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_via,
            'createdVia', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_via2,
            'createdVia[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validated_at,
            'validatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $validated_at2,
            'validatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_workflow_type,
            'testWorkflowType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_workflow_type2,
            'testWorkflowType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_name,
            'locationName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $location_name2,
            'locationName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $results,
            'results', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $results2,
            'results[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $decision,
            'decision', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $decision2,
            'decision[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_start_time,
            'testStartTime', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_start_time2,
            'testStartTime[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_end_time,
            'testEndTime', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_end_time2,
            'testEndTime[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status2,
            'status[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name2,
            'firstName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name2,
            'lastName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company2,
            'company[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email2,
            'email[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender2,
            'gender[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $personal_id_number,
            'personalIdNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $personal_id_number2,
            'personalIdNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number,
            'healthInsurancePolicyNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number2,
            'healthInsurancePolicyNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number,
            'healthInsuranceCompanyNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number2,
            'healthInsuranceCompanyNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'phoneNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number2,
            'phoneNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_of_birth,
            'dateOfBirth', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_of_birth2,
            'dateOfBirth[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_street_and_house_number,
            'addressStreetAndHouseNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_street_and_house_number2,
            'addressStreetAndHouseNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_zip_code,
            'addressZipCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_zip_code2,
            'addressZipCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_city,
            'addressCity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_city2,
            'addressCity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_country,
            'addressCountry', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_country2,
            'addressCountry[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_user_uuid,
            'myProbatixUserUuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_user_uuid2,
            'myProbatixUserUuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_patient_comment,
            'internalPatientComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_patient_comment2,
            'internalPatientComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature,
            'hashSignature', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature2,
            'hashSignature[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientEventsPost
     *
     * Creates a PatientEvent resource.
     *
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The new PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientEvent
     */
    public function apiApiInternalpatientEventsPost($patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsPost'][0])
    {
        list($response) = $this->apiApiInternalpatientEventsPostWithHttpInfo($patient_event, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientEventsPostWithHttpInfo
     *
     * Creates a PatientEvent resource.
     *
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The new PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientEventsPostWithHttpInfo($patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsPost'][0])
    {
        $request = $this->apiApiInternalpatientEventsPostRequest($patient_event, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\PatientEvent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientEvent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientEvent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientEventsPostAsync
     *
     * Creates a PatientEvent resource.
     *
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The new PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsPostAsync($patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsPost'][0])
    {
        return $this->apiApiInternalpatientEventsPostAsyncWithHttpInfo($patient_event, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientEventsPostAsyncWithHttpInfo
     *
     * Creates a PatientEvent resource.
     *
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The new PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsPostAsyncWithHttpInfo($patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientEvent';
        $request = $this->apiApiInternalpatientEventsPostRequest($patient_event, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientEventsPost'
     *
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The new PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientEventsPostRequest($patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsPost'][0])
    {

        // verify the required parameter 'patient_event' is set
        if ($patient_event === null || (is_array($patient_event) && count($patient_event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patient_event when calling apiApiInternalpatientEventsPost'
            );
        }


        $resourcePath = '/api-internal/patient_events';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patient_event)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patient_event));
            } else {
                $httpBody = $patient_event;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientEventsUuidGet
     *
     * Retrieves a PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientEvent
     */
    public function apiApiInternalpatientEventsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidGet'][0])
    {
        list($response) = $this->apiApiInternalpatientEventsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientEventsUuidGetWithHttpInfo
     *
     * Retrieves a PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientEventsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidGet'][0])
    {
        $request = $this->apiApiInternalpatientEventsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientEvent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientEvent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientEvent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientEventsUuidGetAsync
     *
     * Retrieves a PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidGet'][0])
    {
        return $this->apiApiInternalpatientEventsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientEventsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientEvent';
        $request = $this->apiApiInternalpatientEventsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientEventsUuidGet'
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientEventsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalpatientEventsUuidGet'
            );
        }


        $resourcePath = '/api-internal/patient_events/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientEventsUuidPatch
     *
     * Updates the PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The updated PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\PatientEvent
     */
    public function apiApiInternalpatientEventsUuidPatch($uuid, $patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalpatientEventsUuidPatchWithHttpInfo($uuid, $patient_event, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientEventsUuidPatchWithHttpInfo
     *
     * Updates the PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The updated PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\PatientEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientEventsUuidPatchWithHttpInfo($uuid, $patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidPatch'][0])
    {
        $request = $this->apiApiInternalpatientEventsUuidPatchRequest($uuid, $patient_event, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\PatientEvent' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\PatientEvent' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\PatientEvent', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\PatientEvent';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\PatientEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientEventsUuidPatchAsync
     *
     * Updates the PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The updated PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsUuidPatchAsync($uuid, $patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidPatch'][0])
    {
        return $this->apiApiInternalpatientEventsUuidPatchAsyncWithHttpInfo($uuid, $patient_event, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientEventsUuidPatchAsyncWithHttpInfo
     *
     * Updates the PatientEvent resource.
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The updated PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientEventsUuidPatchAsyncWithHttpInfo($uuid, $patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\PatientEvent';
        $request = $this->apiApiInternalpatientEventsUuidPatchRequest($uuid, $patient_event, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientEventsUuidPatch'
     *
     * @param  string $uuid PatientEvent identifier (required)
     * @param  \OpenAPI\Client\Model\PatientEvent $patient_event The updated PatientEvent resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientEventsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientEventsUuidPatchRequest($uuid, $patient_event, string $contentType = self::contentTypes['apiApiInternalpatientEventsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalpatientEventsUuidPatch'
            );
        }

        // verify the required parameter 'patient_event' is set
        if ($patient_event === null || (is_array($patient_event) && count($patient_event) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patient_event when calling apiApiInternalpatientEventsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/patient_events/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patient_event)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patient_event));
            } else {
                $httpBody = $patient_event;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientsGetCollection
     *
     * Retrieves the collection of Patient resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $patient_code  (optional)
     * @param  string[] $patient_code2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $updated_at_before  (optional)
     * @param  string $updated_at_strictly_before  (optional)
     * @param  string $updated_at_after  (optional)
     * @param  string $updated_at_strictly_after  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Patient[]
     */
    public function apiApiInternalpatientsGetCollection($page = 1, $patient_code = null, $patient_code2 = null, $uuid = null, $uuid2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $updated_at_before = null, $updated_at_strictly_before = null, $updated_at_after = null, $updated_at_strictly_after = null, string $contentType = self::contentTypes['apiApiInternalpatientsGetCollection'][0])
    {
        list($response) = $this->apiApiInternalpatientsGetCollectionWithHttpInfo($page, $patient_code, $patient_code2, $uuid, $uuid2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $updated_at_before, $updated_at_strictly_before, $updated_at_after, $updated_at_strictly_after, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Patient resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $patient_code  (optional)
     * @param  string[] $patient_code2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $updated_at_before  (optional)
     * @param  string $updated_at_strictly_before  (optional)
     * @param  string $updated_at_after  (optional)
     * @param  string $updated_at_strictly_after  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Patient[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientsGetCollectionWithHttpInfo($page = 1, $patient_code = null, $patient_code2 = null, $uuid = null, $uuid2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $updated_at_before = null, $updated_at_strictly_before = null, $updated_at_after = null, $updated_at_strictly_after = null, string $contentType = self::contentTypes['apiApiInternalpatientsGetCollection'][0])
    {
        $request = $this->apiApiInternalpatientsGetCollectionRequest($page, $patient_code, $patient_code2, $uuid, $uuid2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $updated_at_before, $updated_at_strictly_before, $updated_at_after, $updated_at_strictly_after, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Patient[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Patient[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Patient[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Patient[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Patient[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientsGetCollectionAsync
     *
     * Retrieves the collection of Patient resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $patient_code  (optional)
     * @param  string[] $patient_code2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $updated_at_before  (optional)
     * @param  string $updated_at_strictly_before  (optional)
     * @param  string $updated_at_after  (optional)
     * @param  string $updated_at_strictly_after  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsGetCollectionAsync($page = 1, $patient_code = null, $patient_code2 = null, $uuid = null, $uuid2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $updated_at_before = null, $updated_at_strictly_before = null, $updated_at_after = null, $updated_at_strictly_after = null, string $contentType = self::contentTypes['apiApiInternalpatientsGetCollection'][0])
    {
        return $this->apiApiInternalpatientsGetCollectionAsyncWithHttpInfo($page, $patient_code, $patient_code2, $uuid, $uuid2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $updated_at_before, $updated_at_strictly_before, $updated_at_after, $updated_at_strictly_after, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Patient resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $patient_code  (optional)
     * @param  string[] $patient_code2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $updated_at_before  (optional)
     * @param  string $updated_at_strictly_before  (optional)
     * @param  string $updated_at_after  (optional)
     * @param  string $updated_at_strictly_after  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsGetCollectionAsyncWithHttpInfo($page = 1, $patient_code = null, $patient_code2 = null, $uuid = null, $uuid2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $updated_at_before = null, $updated_at_strictly_before = null, $updated_at_after = null, $updated_at_strictly_after = null, string $contentType = self::contentTypes['apiApiInternalpatientsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Patient[]';
        $request = $this->apiApiInternalpatientsGetCollectionRequest($page, $patient_code, $patient_code2, $uuid, $uuid2, $first_name, $first_name2, $last_name, $last_name2, $company, $company2, $email, $email2, $gender, $gender2, $personal_id_number, $personal_id_number2, $health_insurance_policy_number, $health_insurance_policy_number2, $health_insurance_company_number, $health_insurance_company_number2, $phone_number, $phone_number2, $date_of_birth, $date_of_birth2, $address_street_and_house_number, $address_street_and_house_number2, $address_zip_code, $address_zip_code2, $address_city, $address_city2, $address_country, $address_country2, $my_probatix_user_uuid, $my_probatix_user_uuid2, $internal_patient_comment, $internal_patient_comment2, $hash_signature, $hash_signature2, $created_at, $created_at2, $updated_at, $updated_at2, $updated_at_before, $updated_at_strictly_before, $updated_at_after, $updated_at_strictly_after, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $patient_code  (optional)
     * @param  string[] $patient_code2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $company  (optional)
     * @param  string[] $company2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  string $gender  (optional)
     * @param  string[] $gender2  (optional)
     * @param  string $personal_id_number  (optional)
     * @param  string[] $personal_id_number2  (optional)
     * @param  string $health_insurance_policy_number  (optional)
     * @param  string[] $health_insurance_policy_number2  (optional)
     * @param  string $health_insurance_company_number  (optional)
     * @param  string[] $health_insurance_company_number2  (optional)
     * @param  string $phone_number  (optional)
     * @param  string[] $phone_number2  (optional)
     * @param  string $date_of_birth  (optional)
     * @param  string $date_of_birth2  (optional)
     * @param  string $address_street_and_house_number  (optional)
     * @param  string[] $address_street_and_house_number2  (optional)
     * @param  string $address_zip_code  (optional)
     * @param  string[] $address_zip_code2  (optional)
     * @param  string $address_city  (optional)
     * @param  string[] $address_city2  (optional)
     * @param  string $address_country  (optional)
     * @param  string[] $address_country2  (optional)
     * @param  string $my_probatix_user_uuid  (optional)
     * @param  string[] $my_probatix_user_uuid2  (optional)
     * @param  string $internal_patient_comment  (optional)
     * @param  string[] $internal_patient_comment2  (optional)
     * @param  string $hash_signature  (optional)
     * @param  string[] $hash_signature2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $updated_at_before  (optional)
     * @param  string $updated_at_strictly_before  (optional)
     * @param  string $updated_at_after  (optional)
     * @param  string $updated_at_strictly_after  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientsGetCollectionRequest($page = 1, $patient_code = null, $patient_code2 = null, $uuid = null, $uuid2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $company = null, $company2 = null, $email = null, $email2 = null, $gender = null, $gender2 = null, $personal_id_number = null, $personal_id_number2 = null, $health_insurance_policy_number = null, $health_insurance_policy_number2 = null, $health_insurance_company_number = null, $health_insurance_company_number2 = null, $phone_number = null, $phone_number2 = null, $date_of_birth = null, $date_of_birth2 = null, $address_street_and_house_number = null, $address_street_and_house_number2 = null, $address_zip_code = null, $address_zip_code2 = null, $address_city = null, $address_city2 = null, $address_country = null, $address_country2 = null, $my_probatix_user_uuid = null, $my_probatix_user_uuid2 = null, $internal_patient_comment = null, $internal_patient_comment2 = null, $hash_signature = null, $hash_signature2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $updated_at_before = null, $updated_at_strictly_before = null, $updated_at_after = null, $updated_at_strictly_after = null, string $contentType = self::contentTypes['apiApiInternalpatientsGetCollection'][0])
    {

















































        $resourcePath = '/api-internal/patients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_code,
            'patientCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $patient_code2,
            'patientCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name2,
            'firstName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name2,
            'lastName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company,
            'company', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $company2,
            'company[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email2,
            'email[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender,
            'gender', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $gender2,
            'gender[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $personal_id_number,
            'personalIdNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $personal_id_number2,
            'personalIdNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number,
            'healthInsurancePolicyNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number2,
            'healthInsurancePolicyNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number,
            'healthInsuranceCompanyNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number2,
            'healthInsuranceCompanyNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number,
            'phoneNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $phone_number2,
            'phoneNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_of_birth,
            'dateOfBirth', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date_of_birth2,
            'dateOfBirth[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_street_and_house_number,
            'addressStreetAndHouseNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_street_and_house_number2,
            'addressStreetAndHouseNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_zip_code,
            'addressZipCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_zip_code2,
            'addressZipCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_city,
            'addressCity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_city2,
            'addressCity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_country,
            'addressCountry', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_country2,
            'addressCountry[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_user_uuid,
            'myProbatixUserUuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_user_uuid2,
            'myProbatixUserUuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_patient_comment,
            'internalPatientComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_patient_comment2,
            'internalPatientComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature,
            'hashSignature', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $hash_signature2,
            'hashSignature[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_before,
            'updatedAt[before]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_strictly_before,
            'updatedAt[strictly_before]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_after,
            'updatedAt[after]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at_strictly_after,
            'updatedAt[strictly_after]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientsPost
     *
     * Creates a Patient resource.
     *
     * @param  \OpenAPI\Client\Model\Patient $patient The new Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Patient
     */
    public function apiApiInternalpatientsPost($patient, string $contentType = self::contentTypes['apiApiInternalpatientsPost'][0])
    {
        list($response) = $this->apiApiInternalpatientsPostWithHttpInfo($patient, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientsPostWithHttpInfo
     *
     * Creates a Patient resource.
     *
     * @param  \OpenAPI\Client\Model\Patient $patient The new Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Patient, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientsPostWithHttpInfo($patient, string $contentType = self::contentTypes['apiApiInternalpatientsPost'][0])
    {
        $request = $this->apiApiInternalpatientsPostRequest($patient, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Patient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Patient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Patient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Patient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Patient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientsPostAsync
     *
     * Creates a Patient resource.
     *
     * @param  \OpenAPI\Client\Model\Patient $patient The new Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsPostAsync($patient, string $contentType = self::contentTypes['apiApiInternalpatientsPost'][0])
    {
        return $this->apiApiInternalpatientsPostAsyncWithHttpInfo($patient, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientsPostAsyncWithHttpInfo
     *
     * Creates a Patient resource.
     *
     * @param  \OpenAPI\Client\Model\Patient $patient The new Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsPostAsyncWithHttpInfo($patient, string $contentType = self::contentTypes['apiApiInternalpatientsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Patient';
        $request = $this->apiApiInternalpatientsPostRequest($patient, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientsPost'
     *
     * @param  \OpenAPI\Client\Model\Patient $patient The new Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientsPostRequest($patient, string $contentType = self::contentTypes['apiApiInternalpatientsPost'][0])
    {

        // verify the required parameter 'patient' is set
        if ($patient === null || (is_array($patient) && count($patient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patient when calling apiApiInternalpatientsPost'
            );
        }


        $resourcePath = '/api-internal/patients';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patient)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patient));
            } else {
                $httpBody = $patient;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientsUuidGet
     *
     * Retrieves a Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Patient
     */
    public function apiApiInternalpatientsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalpatientsUuidGet'][0])
    {
        list($response) = $this->apiApiInternalpatientsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientsUuidGetWithHttpInfo
     *
     * Retrieves a Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Patient, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalpatientsUuidGet'][0])
    {
        $request = $this->apiApiInternalpatientsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Patient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Patient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Patient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Patient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Patient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientsUuidGetAsync
     *
     * Retrieves a Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalpatientsUuidGet'][0])
    {
        return $this->apiApiInternalpatientsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalpatientsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Patient';
        $request = $this->apiApiInternalpatientsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientsUuidGet'
     *
     * @param  string $uuid Patient identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalpatientsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalpatientsUuidGet'
            );
        }


        $resourcePath = '/api-internal/patients/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalpatientsUuidPatch
     *
     * Updates the Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  \OpenAPI\Client\Model\Patient $patient The updated Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Patient
     */
    public function apiApiInternalpatientsUuidPatch($uuid, $patient, string $contentType = self::contentTypes['apiApiInternalpatientsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalpatientsUuidPatchWithHttpInfo($uuid, $patient, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalpatientsUuidPatchWithHttpInfo
     *
     * Updates the Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  \OpenAPI\Client\Model\Patient $patient The updated Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Patient, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalpatientsUuidPatchWithHttpInfo($uuid, $patient, string $contentType = self::contentTypes['apiApiInternalpatientsUuidPatch'][0])
    {
        $request = $this->apiApiInternalpatientsUuidPatchRequest($uuid, $patient, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Patient' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Patient' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Patient', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Patient';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Patient',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalpatientsUuidPatchAsync
     *
     * Updates the Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  \OpenAPI\Client\Model\Patient $patient The updated Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsUuidPatchAsync($uuid, $patient, string $contentType = self::contentTypes['apiApiInternalpatientsUuidPatch'][0])
    {
        return $this->apiApiInternalpatientsUuidPatchAsyncWithHttpInfo($uuid, $patient, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalpatientsUuidPatchAsyncWithHttpInfo
     *
     * Updates the Patient resource.
     *
     * @param  string $uuid Patient identifier (required)
     * @param  \OpenAPI\Client\Model\Patient $patient The updated Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalpatientsUuidPatchAsyncWithHttpInfo($uuid, $patient, string $contentType = self::contentTypes['apiApiInternalpatientsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Patient';
        $request = $this->apiApiInternalpatientsUuidPatchRequest($uuid, $patient, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalpatientsUuidPatch'
     *
     * @param  string $uuid Patient identifier (required)
     * @param  \OpenAPI\Client\Model\Patient $patient The updated Patient resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalpatientsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalpatientsUuidPatchRequest($uuid, $patient, string $contentType = self::contentTypes['apiApiInternalpatientsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalpatientsUuidPatch'
            );
        }

        // verify the required parameter 'patient' is set
        if ($patient === null || (is_array($patient) && count($patient) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $patient when calling apiApiInternalpatientsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/patients/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($patient)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($patient));
            } else {
                $httpBody = $patient;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersGetCollection
     *
     * Retrieves the collection of ProbeIdentifier resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $id  (optional)
     * @param  string[] $id2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProbeIdentifier[]
     */
    public function apiApiInternalprobeIdentifiersGetCollection($page = 1, $id = null, $id2 = null, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalprobeIdentifiersGetCollectionWithHttpInfo($page, $id, $id2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalprobeIdentifiersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of ProbeIdentifier resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $id  (optional)
     * @param  string[] $id2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProbeIdentifier[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalprobeIdentifiersGetCollectionWithHttpInfo($page = 1, $id = null, $id2 = null, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'][0])
    {
        $request = $this->apiApiInternalprobeIdentifiersGetCollectionRequest($page, $id, $id2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProbeIdentifier[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProbeIdentifier[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProbeIdentifier[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProbeIdentifier[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProbeIdentifier[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalprobeIdentifiersGetCollectionAsync
     *
     * Retrieves the collection of ProbeIdentifier resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $id  (optional)
     * @param  string[] $id2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersGetCollectionAsync($page = 1, $id = null, $id2 = null, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'][0])
    {
        return $this->apiApiInternalprobeIdentifiersGetCollectionAsyncWithHttpInfo($page, $id, $id2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of ProbeIdentifier resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $id  (optional)
     * @param  string[] $id2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersGetCollectionAsyncWithHttpInfo($page = 1, $id = null, $id2 = null, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProbeIdentifier[]';
        $request = $this->apiApiInternalprobeIdentifiersGetCollectionRequest($page, $id, $id2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalprobeIdentifiersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $id  (optional)
     * @param  string[] $id2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalprobeIdentifiersGetCollectionRequest($page = 1, $id = null, $id2 = null, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersGetCollection'][0])
    {





        $resourcePath = '/api-internal/probe_identifiers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id2,
            'id[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdGet
     *
     * Retrieves a ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProbeIdentifier
     */
    public function apiApiInternalprobeIdentifiersIdGet($id, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdGet'][0])
    {
        list($response) = $this->apiApiInternalprobeIdentifiersIdGetWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdGetWithHttpInfo
     *
     * Retrieves a ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProbeIdentifier, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalprobeIdentifiersIdGetWithHttpInfo($id, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdGet'][0])
    {
        $request = $this->apiApiInternalprobeIdentifiersIdGetRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProbeIdentifier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProbeIdentifier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProbeIdentifier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProbeIdentifier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdGetAsync
     *
     * Retrieves a ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersIdGetAsync($id, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdGet'][0])
    {
        return $this->apiApiInternalprobeIdentifiersIdGetAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdGetAsyncWithHttpInfo
     *
     * Retrieves a ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersIdGetAsyncWithHttpInfo($id, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
        $request = $this->apiApiInternalprobeIdentifiersIdGetRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalprobeIdentifiersIdGet'
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalprobeIdentifiersIdGetRequest($id, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiApiInternalprobeIdentifiersIdGet'
            );
        }


        $resourcePath = '/api-internal/probe_identifiers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdPatch
     *
     * Updates the ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The updated ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProbeIdentifier
     */
    public function apiApiInternalprobeIdentifiersIdPatch($id, $probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'][0])
    {
        list($response) = $this->apiApiInternalprobeIdentifiersIdPatchWithHttpInfo($id, $probe_identifier, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdPatchWithHttpInfo
     *
     * Updates the ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The updated ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProbeIdentifier, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalprobeIdentifiersIdPatchWithHttpInfo($id, $probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'][0])
    {
        $request = $this->apiApiInternalprobeIdentifiersIdPatchRequest($id, $probe_identifier, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\ProbeIdentifier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProbeIdentifier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProbeIdentifier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProbeIdentifier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdPatchAsync
     *
     * Updates the ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The updated ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersIdPatchAsync($id, $probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'][0])
    {
        return $this->apiApiInternalprobeIdentifiersIdPatchAsyncWithHttpInfo($id, $probe_identifier, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersIdPatchAsyncWithHttpInfo
     *
     * Updates the ProbeIdentifier resource.
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The updated ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersIdPatchAsyncWithHttpInfo($id, $probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
        $request = $this->apiApiInternalprobeIdentifiersIdPatchRequest($id, $probe_identifier, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalprobeIdentifiersIdPatch'
     *
     * @param  string $id ProbeIdentifier identifier (required)
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The updated ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalprobeIdentifiersIdPatchRequest($id, $probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersIdPatch'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiApiInternalprobeIdentifiersIdPatch'
            );
        }

        // verify the required parameter 'probe_identifier' is set
        if ($probe_identifier === null || (is_array($probe_identifier) && count($probe_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $probe_identifier when calling apiApiInternalprobeIdentifiersIdPatch'
            );
        }


        $resourcePath = '/api-internal/probe_identifiers/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($probe_identifier)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($probe_identifier));
            } else {
                $httpBody = $probe_identifier;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersPost
     *
     * Creates a ProbeIdentifier resource.
     *
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The new ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\ProbeIdentifier
     */
    public function apiApiInternalprobeIdentifiersPost($probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersPost'][0])
    {
        list($response) = $this->apiApiInternalprobeIdentifiersPostWithHttpInfo($probe_identifier, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalprobeIdentifiersPostWithHttpInfo
     *
     * Creates a ProbeIdentifier resource.
     *
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The new ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\ProbeIdentifier, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalprobeIdentifiersPostWithHttpInfo($probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersPost'][0])
    {
        $request = $this->apiApiInternalprobeIdentifiersPostRequest($probe_identifier, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\ProbeIdentifier' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\ProbeIdentifier' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\ProbeIdentifier', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\ProbeIdentifier',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalprobeIdentifiersPostAsync
     *
     * Creates a ProbeIdentifier resource.
     *
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The new ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersPostAsync($probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersPost'][0])
    {
        return $this->apiApiInternalprobeIdentifiersPostAsyncWithHttpInfo($probe_identifier, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalprobeIdentifiersPostAsyncWithHttpInfo
     *
     * Creates a ProbeIdentifier resource.
     *
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The new ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalprobeIdentifiersPostAsyncWithHttpInfo($probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\ProbeIdentifier';
        $request = $this->apiApiInternalprobeIdentifiersPostRequest($probe_identifier, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalprobeIdentifiersPost'
     *
     * @param  \OpenAPI\Client\Model\ProbeIdentifier $probe_identifier The new ProbeIdentifier resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalprobeIdentifiersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalprobeIdentifiersPostRequest($probe_identifier, string $contentType = self::contentTypes['apiApiInternalprobeIdentifiersPost'][0])
    {

        // verify the required parameter 'probe_identifier' is set
        if ($probe_identifier === null || (is_array($probe_identifier) && count($probe_identifier) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $probe_identifier when calling apiApiInternalprobeIdentifiersPost'
            );
        }


        $resourcePath = '/api-internal/probe_identifiers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($probe_identifier)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($probe_identifier));
            } else {
                $httpBody = $probe_identifier;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalproductsGetCollection
     *
     * Retrieves the collection of Product resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  bool $default  (optional)
     * @param  bool[] $default2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  bool $automatic_booking_confirmation  (optional)
     * @param  bool[] $automatic_booking_confirmation2  (optional)
     * @param  bool $automatic_results_notification  (optional)
     * @param  bool[] $automatic_results_notification2  (optional)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  int $tax_percentage  (optional)
     * @param  int[] $tax_percentage2  (optional)
     * @param  bool $requires_eligibility_self_confirmation  (optional)
     * @param  bool[] $requires_eligibility_self_confirmation2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $visibility  (optional)
     * @param  string[] $visibility2  (optional)
     * @param  int $max_bookings_per_order  (optional)
     * @param  int[] $max_bookings_per_order2  (optional)
     * @param  int $minimum_patient_age  (optional)
     * @param  int[] $minimum_patient_age2  (optional)
     * @param  bool $show_comment_field_for_customers  (optional)
     * @param  bool[] $show_comment_field_for_customers2  (optional)
     * @param  bool $is_personal_id_required  (optional)
     * @param  bool[] $is_personal_id_required2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $eligibility_reasons  (optional)
     * @param  string[] $eligibility_reasons2  (optional)
     * @param  bool $internal_code_required  (optional)
     * @param  bool[] $internal_code_required2  (optional)
     * @param  bool $health_insurance_policy_number_required  (optional)
     * @param  bool[] $health_insurance_policy_number_required2  (optional)
     * @param  bool $health_insurance_company_number_required  (optional)
     * @param  bool[] $health_insurance_company_number_required2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Product[]
     */
    public function apiApiInternalproductsGetCollection($page = 1, $name = null, $name2 = null, $test_type = null, $test_type2 = null, $default = null, $default2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $automatic_booking_confirmation = null, $automatic_booking_confirmation2 = null, $automatic_results_notification = null, $automatic_results_notification2 = null, $url_key = null, $url_key2 = null, $tax_percentage = null, $tax_percentage2 = null, $requires_eligibility_self_confirmation = null, $requires_eligibility_self_confirmation2 = null, $loinc = null, $loinc2 = null, $loinc_display = null, $loinc_display2 = null, $visibility = null, $visibility2 = null, $max_bookings_per_order = null, $max_bookings_per_order2 = null, $minimum_patient_age = null, $minimum_patient_age2 = null, $show_comment_field_for_customers = null, $show_comment_field_for_customers2 = null, $is_personal_id_required = null, $is_personal_id_required2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $eligibility_reasons = null, $eligibility_reasons2 = null, $internal_code_required = null, $internal_code_required2 = null, $health_insurance_policy_number_required = null, $health_insurance_policy_number_required2 = null, $health_insurance_company_number_required = null, $health_insurance_company_number_required2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalproductsGetCollection'][0])
    {
        list($response) = $this->apiApiInternalproductsGetCollectionWithHttpInfo($page, $name, $name2, $test_type, $test_type2, $default, $default2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $automatic_booking_confirmation, $automatic_booking_confirmation2, $automatic_results_notification, $automatic_results_notification2, $url_key, $url_key2, $tax_percentage, $tax_percentage2, $requires_eligibility_self_confirmation, $requires_eligibility_self_confirmation2, $loinc, $loinc2, $loinc_display, $loinc_display2, $visibility, $visibility2, $max_bookings_per_order, $max_bookings_per_order2, $minimum_patient_age, $minimum_patient_age2, $show_comment_field_for_customers, $show_comment_field_for_customers2, $is_personal_id_required, $is_personal_id_required2, $test_workflow_type, $test_workflow_type2, $eligibility_reasons, $eligibility_reasons2, $internal_code_required, $internal_code_required2, $health_insurance_policy_number_required, $health_insurance_policy_number_required2, $health_insurance_company_number_required, $health_insurance_company_number_required2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalproductsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Product resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  bool $default  (optional)
     * @param  bool[] $default2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  bool $automatic_booking_confirmation  (optional)
     * @param  bool[] $automatic_booking_confirmation2  (optional)
     * @param  bool $automatic_results_notification  (optional)
     * @param  bool[] $automatic_results_notification2  (optional)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  int $tax_percentage  (optional)
     * @param  int[] $tax_percentage2  (optional)
     * @param  bool $requires_eligibility_self_confirmation  (optional)
     * @param  bool[] $requires_eligibility_self_confirmation2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $visibility  (optional)
     * @param  string[] $visibility2  (optional)
     * @param  int $max_bookings_per_order  (optional)
     * @param  int[] $max_bookings_per_order2  (optional)
     * @param  int $minimum_patient_age  (optional)
     * @param  int[] $minimum_patient_age2  (optional)
     * @param  bool $show_comment_field_for_customers  (optional)
     * @param  bool[] $show_comment_field_for_customers2  (optional)
     * @param  bool $is_personal_id_required  (optional)
     * @param  bool[] $is_personal_id_required2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $eligibility_reasons  (optional)
     * @param  string[] $eligibility_reasons2  (optional)
     * @param  bool $internal_code_required  (optional)
     * @param  bool[] $internal_code_required2  (optional)
     * @param  bool $health_insurance_policy_number_required  (optional)
     * @param  bool[] $health_insurance_policy_number_required2  (optional)
     * @param  bool $health_insurance_company_number_required  (optional)
     * @param  bool[] $health_insurance_company_number_required2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Product[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalproductsGetCollectionWithHttpInfo($page = 1, $name = null, $name2 = null, $test_type = null, $test_type2 = null, $default = null, $default2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $automatic_booking_confirmation = null, $automatic_booking_confirmation2 = null, $automatic_results_notification = null, $automatic_results_notification2 = null, $url_key = null, $url_key2 = null, $tax_percentage = null, $tax_percentage2 = null, $requires_eligibility_self_confirmation = null, $requires_eligibility_self_confirmation2 = null, $loinc = null, $loinc2 = null, $loinc_display = null, $loinc_display2 = null, $visibility = null, $visibility2 = null, $max_bookings_per_order = null, $max_bookings_per_order2 = null, $minimum_patient_age = null, $minimum_patient_age2 = null, $show_comment_field_for_customers = null, $show_comment_field_for_customers2 = null, $is_personal_id_required = null, $is_personal_id_required2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $eligibility_reasons = null, $eligibility_reasons2 = null, $internal_code_required = null, $internal_code_required2 = null, $health_insurance_policy_number_required = null, $health_insurance_policy_number_required2 = null, $health_insurance_company_number_required = null, $health_insurance_company_number_required2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalproductsGetCollection'][0])
    {
        $request = $this->apiApiInternalproductsGetCollectionRequest($page, $name, $name2, $test_type, $test_type2, $default, $default2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $automatic_booking_confirmation, $automatic_booking_confirmation2, $automatic_results_notification, $automatic_results_notification2, $url_key, $url_key2, $tax_percentage, $tax_percentage2, $requires_eligibility_self_confirmation, $requires_eligibility_self_confirmation2, $loinc, $loinc2, $loinc_display, $loinc_display2, $visibility, $visibility2, $max_bookings_per_order, $max_bookings_per_order2, $minimum_patient_age, $minimum_patient_age2, $show_comment_field_for_customers, $show_comment_field_for_customers2, $is_personal_id_required, $is_personal_id_required2, $test_workflow_type, $test_workflow_type2, $eligibility_reasons, $eligibility_reasons2, $internal_code_required, $internal_code_required2, $health_insurance_policy_number_required, $health_insurance_policy_number_required2, $health_insurance_company_number_required, $health_insurance_company_number_required2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Product[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Product[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Product[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Product[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Product[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalproductsGetCollectionAsync
     *
     * Retrieves the collection of Product resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  bool $default  (optional)
     * @param  bool[] $default2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  bool $automatic_booking_confirmation  (optional)
     * @param  bool[] $automatic_booking_confirmation2  (optional)
     * @param  bool $automatic_results_notification  (optional)
     * @param  bool[] $automatic_results_notification2  (optional)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  int $tax_percentage  (optional)
     * @param  int[] $tax_percentage2  (optional)
     * @param  bool $requires_eligibility_self_confirmation  (optional)
     * @param  bool[] $requires_eligibility_self_confirmation2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $visibility  (optional)
     * @param  string[] $visibility2  (optional)
     * @param  int $max_bookings_per_order  (optional)
     * @param  int[] $max_bookings_per_order2  (optional)
     * @param  int $minimum_patient_age  (optional)
     * @param  int[] $minimum_patient_age2  (optional)
     * @param  bool $show_comment_field_for_customers  (optional)
     * @param  bool[] $show_comment_field_for_customers2  (optional)
     * @param  bool $is_personal_id_required  (optional)
     * @param  bool[] $is_personal_id_required2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $eligibility_reasons  (optional)
     * @param  string[] $eligibility_reasons2  (optional)
     * @param  bool $internal_code_required  (optional)
     * @param  bool[] $internal_code_required2  (optional)
     * @param  bool $health_insurance_policy_number_required  (optional)
     * @param  bool[] $health_insurance_policy_number_required2  (optional)
     * @param  bool $health_insurance_company_number_required  (optional)
     * @param  bool[] $health_insurance_company_number_required2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsGetCollectionAsync($page = 1, $name = null, $name2 = null, $test_type = null, $test_type2 = null, $default = null, $default2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $automatic_booking_confirmation = null, $automatic_booking_confirmation2 = null, $automatic_results_notification = null, $automatic_results_notification2 = null, $url_key = null, $url_key2 = null, $tax_percentage = null, $tax_percentage2 = null, $requires_eligibility_self_confirmation = null, $requires_eligibility_self_confirmation2 = null, $loinc = null, $loinc2 = null, $loinc_display = null, $loinc_display2 = null, $visibility = null, $visibility2 = null, $max_bookings_per_order = null, $max_bookings_per_order2 = null, $minimum_patient_age = null, $minimum_patient_age2 = null, $show_comment_field_for_customers = null, $show_comment_field_for_customers2 = null, $is_personal_id_required = null, $is_personal_id_required2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $eligibility_reasons = null, $eligibility_reasons2 = null, $internal_code_required = null, $internal_code_required2 = null, $health_insurance_policy_number_required = null, $health_insurance_policy_number_required2 = null, $health_insurance_company_number_required = null, $health_insurance_company_number_required2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalproductsGetCollection'][0])
    {
        return $this->apiApiInternalproductsGetCollectionAsyncWithHttpInfo($page, $name, $name2, $test_type, $test_type2, $default, $default2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $automatic_booking_confirmation, $automatic_booking_confirmation2, $automatic_results_notification, $automatic_results_notification2, $url_key, $url_key2, $tax_percentage, $tax_percentage2, $requires_eligibility_self_confirmation, $requires_eligibility_self_confirmation2, $loinc, $loinc2, $loinc_display, $loinc_display2, $visibility, $visibility2, $max_bookings_per_order, $max_bookings_per_order2, $minimum_patient_age, $minimum_patient_age2, $show_comment_field_for_customers, $show_comment_field_for_customers2, $is_personal_id_required, $is_personal_id_required2, $test_workflow_type, $test_workflow_type2, $eligibility_reasons, $eligibility_reasons2, $internal_code_required, $internal_code_required2, $health_insurance_policy_number_required, $health_insurance_policy_number_required2, $health_insurance_company_number_required, $health_insurance_company_number_required2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalproductsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Product resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  bool $default  (optional)
     * @param  bool[] $default2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  bool $automatic_booking_confirmation  (optional)
     * @param  bool[] $automatic_booking_confirmation2  (optional)
     * @param  bool $automatic_results_notification  (optional)
     * @param  bool[] $automatic_results_notification2  (optional)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  int $tax_percentage  (optional)
     * @param  int[] $tax_percentage2  (optional)
     * @param  bool $requires_eligibility_self_confirmation  (optional)
     * @param  bool[] $requires_eligibility_self_confirmation2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $visibility  (optional)
     * @param  string[] $visibility2  (optional)
     * @param  int $max_bookings_per_order  (optional)
     * @param  int[] $max_bookings_per_order2  (optional)
     * @param  int $minimum_patient_age  (optional)
     * @param  int[] $minimum_patient_age2  (optional)
     * @param  bool $show_comment_field_for_customers  (optional)
     * @param  bool[] $show_comment_field_for_customers2  (optional)
     * @param  bool $is_personal_id_required  (optional)
     * @param  bool[] $is_personal_id_required2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $eligibility_reasons  (optional)
     * @param  string[] $eligibility_reasons2  (optional)
     * @param  bool $internal_code_required  (optional)
     * @param  bool[] $internal_code_required2  (optional)
     * @param  bool $health_insurance_policy_number_required  (optional)
     * @param  bool[] $health_insurance_policy_number_required2  (optional)
     * @param  bool $health_insurance_company_number_required  (optional)
     * @param  bool[] $health_insurance_company_number_required2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsGetCollectionAsyncWithHttpInfo($page = 1, $name = null, $name2 = null, $test_type = null, $test_type2 = null, $default = null, $default2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $automatic_booking_confirmation = null, $automatic_booking_confirmation2 = null, $automatic_results_notification = null, $automatic_results_notification2 = null, $url_key = null, $url_key2 = null, $tax_percentage = null, $tax_percentage2 = null, $requires_eligibility_self_confirmation = null, $requires_eligibility_self_confirmation2 = null, $loinc = null, $loinc2 = null, $loinc_display = null, $loinc_display2 = null, $visibility = null, $visibility2 = null, $max_bookings_per_order = null, $max_bookings_per_order2 = null, $minimum_patient_age = null, $minimum_patient_age2 = null, $show_comment_field_for_customers = null, $show_comment_field_for_customers2 = null, $is_personal_id_required = null, $is_personal_id_required2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $eligibility_reasons = null, $eligibility_reasons2 = null, $internal_code_required = null, $internal_code_required2 = null, $health_insurance_policy_number_required = null, $health_insurance_policy_number_required2 = null, $health_insurance_company_number_required = null, $health_insurance_company_number_required2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalproductsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Product[]';
        $request = $this->apiApiInternalproductsGetCollectionRequest($page, $name, $name2, $test_type, $test_type2, $default, $default2, $test_duration_in_minutes, $test_duration_in_minutes2, $description, $description2, $single_gross_amount, $single_gross_amount2, $automatic_booking_confirmation, $automatic_booking_confirmation2, $automatic_results_notification, $automatic_results_notification2, $url_key, $url_key2, $tax_percentage, $tax_percentage2, $requires_eligibility_self_confirmation, $requires_eligibility_self_confirmation2, $loinc, $loinc2, $loinc_display, $loinc_display2, $visibility, $visibility2, $max_bookings_per_order, $max_bookings_per_order2, $minimum_patient_age, $minimum_patient_age2, $show_comment_field_for_customers, $show_comment_field_for_customers2, $is_personal_id_required, $is_personal_id_required2, $test_workflow_type, $test_workflow_type2, $eligibility_reasons, $eligibility_reasons2, $internal_code_required, $internal_code_required2, $health_insurance_policy_number_required, $health_insurance_policy_number_required2, $health_insurance_company_number_required, $health_insurance_company_number_required2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalproductsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $name  (optional)
     * @param  string[] $name2  (optional)
     * @param  string $test_type  (optional)
     * @param  string[] $test_type2  (optional)
     * @param  bool $default  (optional)
     * @param  bool[] $default2  (optional)
     * @param  int $test_duration_in_minutes  (optional)
     * @param  int[] $test_duration_in_minutes2  (optional)
     * @param  string $description  (optional)
     * @param  string[] $description2  (optional)
     * @param  int $single_gross_amount  (optional)
     * @param  int[] $single_gross_amount2  (optional)
     * @param  bool $automatic_booking_confirmation  (optional)
     * @param  bool[] $automatic_booking_confirmation2  (optional)
     * @param  bool $automatic_results_notification  (optional)
     * @param  bool[] $automatic_results_notification2  (optional)
     * @param  string $url_key  (optional)
     * @param  string[] $url_key2  (optional)
     * @param  int $tax_percentage  (optional)
     * @param  int[] $tax_percentage2  (optional)
     * @param  bool $requires_eligibility_self_confirmation  (optional)
     * @param  bool[] $requires_eligibility_self_confirmation2  (optional)
     * @param  string $loinc  (optional)
     * @param  string[] $loinc2  (optional)
     * @param  string $loinc_display  (optional)
     * @param  string[] $loinc_display2  (optional)
     * @param  string $visibility  (optional)
     * @param  string[] $visibility2  (optional)
     * @param  int $max_bookings_per_order  (optional)
     * @param  int[] $max_bookings_per_order2  (optional)
     * @param  int $minimum_patient_age  (optional)
     * @param  int[] $minimum_patient_age2  (optional)
     * @param  bool $show_comment_field_for_customers  (optional)
     * @param  bool[] $show_comment_field_for_customers2  (optional)
     * @param  bool $is_personal_id_required  (optional)
     * @param  bool[] $is_personal_id_required2  (optional)
     * @param  string $test_workflow_type  (optional)
     * @param  string[] $test_workflow_type2  (optional)
     * @param  string $eligibility_reasons  (optional)
     * @param  string[] $eligibility_reasons2  (optional)
     * @param  bool $internal_code_required  (optional)
     * @param  bool[] $internal_code_required2  (optional)
     * @param  bool $health_insurance_policy_number_required  (optional)
     * @param  bool[] $health_insurance_policy_number_required2  (optional)
     * @param  bool $health_insurance_company_number_required  (optional)
     * @param  bool[] $health_insurance_company_number_required2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalproductsGetCollectionRequest($page = 1, $name = null, $name2 = null, $test_type = null, $test_type2 = null, $default = null, $default2 = null, $test_duration_in_minutes = null, $test_duration_in_minutes2 = null, $description = null, $description2 = null, $single_gross_amount = null, $single_gross_amount2 = null, $automatic_booking_confirmation = null, $automatic_booking_confirmation2 = null, $automatic_results_notification = null, $automatic_results_notification2 = null, $url_key = null, $url_key2 = null, $tax_percentage = null, $tax_percentage2 = null, $requires_eligibility_self_confirmation = null, $requires_eligibility_self_confirmation2 = null, $loinc = null, $loinc2 = null, $loinc_display = null, $loinc_display2 = null, $visibility = null, $visibility2 = null, $max_bookings_per_order = null, $max_bookings_per_order2 = null, $minimum_patient_age = null, $minimum_patient_age2 = null, $show_comment_field_for_customers = null, $show_comment_field_for_customers2 = null, $is_personal_id_required = null, $is_personal_id_required2 = null, $test_workflow_type = null, $test_workflow_type2 = null, $eligibility_reasons = null, $eligibility_reasons2 = null, $internal_code_required = null, $internal_code_required2 = null, $health_insurance_policy_number_required = null, $health_insurance_policy_number_required2 = null, $health_insurance_company_number_required = null, $health_insurance_company_number_required2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalproductsGetCollection'][0])
    {























































        $resourcePath = '/api-internal/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name,
            'name', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $name2,
            'name[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_type,
            'testType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_type2,
            'testType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default,
            'default', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $default2,
            'default[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_duration_in_minutes,
            'testDurationInMinutes', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_duration_in_minutes2,
            'testDurationInMinutes[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description,
            'description', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $description2,
            'description[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_gross_amount,
            'singleGrossAmount', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $single_gross_amount2,
            'singleGrossAmount[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $automatic_booking_confirmation,
            'automaticBookingConfirmation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $automatic_booking_confirmation2,
            'automaticBookingConfirmation[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $automatic_results_notification,
            'automaticResultsNotification', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $automatic_results_notification2,
            'automaticResultsNotification[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_key,
            'urlKey', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_key2,
            'urlKey[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax_percentage,
            'taxPercentage', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tax_percentage2,
            'taxPercentage[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requires_eligibility_self_confirmation,
            'requiresEligibilitySelfConfirmation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $requires_eligibility_self_confirmation2,
            'requiresEligibilitySelfConfirmation[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc,
            'loinc', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc2,
            'loinc[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc_display,
            'loincDisplay', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $loinc_display2,
            'loincDisplay[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility,
            'visibility', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $visibility2,
            'visibility[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_bookings_per_order,
            'maxBookingsPerOrder', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_bookings_per_order2,
            'maxBookingsPerOrder[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minimum_patient_age,
            'minimumPatientAge', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $minimum_patient_age2,
            'minimumPatientAge[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_comment_field_for_customers,
            'showCommentFieldForCustomers', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_comment_field_for_customers2,
            'showCommentFieldForCustomers[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_personal_id_required,
            'isPersonalIdRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_personal_id_required2,
            'isPersonalIdRequired[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_workflow_type,
            'testWorkflowType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_workflow_type2,
            'testWorkflowType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $eligibility_reasons,
            'eligibilityReasons', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $eligibility_reasons2,
            'eligibilityReasons[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code_required,
            'internalCodeRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code_required2,
            'internalCodeRequired[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number_required,
            'healthInsurancePolicyNumberRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_policy_number_required2,
            'healthInsurancePolicyNumberRequired[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number_required,
            'healthInsuranceCompanyNumberRequired', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $health_insurance_company_number_required2,
            'healthInsuranceCompanyNumberRequired[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalproductsPost
     *
     * Creates a Product resource.
     *
     * @param  \OpenAPI\Client\Model\Product $product The new Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Product
     */
    public function apiApiInternalproductsPost($product, string $contentType = self::contentTypes['apiApiInternalproductsPost'][0])
    {
        list($response) = $this->apiApiInternalproductsPostWithHttpInfo($product, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalproductsPostWithHttpInfo
     *
     * Creates a Product resource.
     *
     * @param  \OpenAPI\Client\Model\Product $product The new Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalproductsPostWithHttpInfo($product, string $contentType = self::contentTypes['apiApiInternalproductsPost'][0])
    {
        $request = $this->apiApiInternalproductsPostRequest($product, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Product' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Product' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Product', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Product';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalproductsPostAsync
     *
     * Creates a Product resource.
     *
     * @param  \OpenAPI\Client\Model\Product $product The new Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsPostAsync($product, string $contentType = self::contentTypes['apiApiInternalproductsPost'][0])
    {
        return $this->apiApiInternalproductsPostAsyncWithHttpInfo($product, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalproductsPostAsyncWithHttpInfo
     *
     * Creates a Product resource.
     *
     * @param  \OpenAPI\Client\Model\Product $product The new Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsPostAsyncWithHttpInfo($product, string $contentType = self::contentTypes['apiApiInternalproductsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Product';
        $request = $this->apiApiInternalproductsPostRequest($product, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalproductsPost'
     *
     * @param  \OpenAPI\Client\Model\Product $product The new Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalproductsPostRequest($product, string $contentType = self::contentTypes['apiApiInternalproductsPost'][0])
    {

        // verify the required parameter 'product' is set
        if ($product === null || (is_array($product) && count($product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product when calling apiApiInternalproductsPost'
            );
        }


        $resourcePath = '/api-internal/products';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product));
            } else {
                $httpBody = $product;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalproductsUuidGet
     *
     * Retrieves a Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Product
     */
    public function apiApiInternalproductsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalproductsUuidGet'][0])
    {
        list($response) = $this->apiApiInternalproductsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalproductsUuidGetWithHttpInfo
     *
     * Retrieves a Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalproductsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalproductsUuidGet'][0])
    {
        $request = $this->apiApiInternalproductsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Product' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Product' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Product', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Product';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalproductsUuidGetAsync
     *
     * Retrieves a Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalproductsUuidGet'][0])
    {
        return $this->apiApiInternalproductsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalproductsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalproductsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Product';
        $request = $this->apiApiInternalproductsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalproductsUuidGet'
     *
     * @param  string $uuid Product identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalproductsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalproductsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalproductsUuidGet'
            );
        }


        $resourcePath = '/api-internal/products/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalproductsUuidPatch
     *
     * Updates the Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  \OpenAPI\Client\Model\Product $product The updated Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Product
     */
    public function apiApiInternalproductsUuidPatch($uuid, $product, string $contentType = self::contentTypes['apiApiInternalproductsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalproductsUuidPatchWithHttpInfo($uuid, $product, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalproductsUuidPatchWithHttpInfo
     *
     * Updates the Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  \OpenAPI\Client\Model\Product $product The updated Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Product, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalproductsUuidPatchWithHttpInfo($uuid, $product, string $contentType = self::contentTypes['apiApiInternalproductsUuidPatch'][0])
    {
        $request = $this->apiApiInternalproductsUuidPatchRequest($uuid, $product, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Product' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Product' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Product', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Product';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Product',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalproductsUuidPatchAsync
     *
     * Updates the Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  \OpenAPI\Client\Model\Product $product The updated Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsUuidPatchAsync($uuid, $product, string $contentType = self::contentTypes['apiApiInternalproductsUuidPatch'][0])
    {
        return $this->apiApiInternalproductsUuidPatchAsyncWithHttpInfo($uuid, $product, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalproductsUuidPatchAsyncWithHttpInfo
     *
     * Updates the Product resource.
     *
     * @param  string $uuid Product identifier (required)
     * @param  \OpenAPI\Client\Model\Product $product The updated Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalproductsUuidPatchAsyncWithHttpInfo($uuid, $product, string $contentType = self::contentTypes['apiApiInternalproductsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Product';
        $request = $this->apiApiInternalproductsUuidPatchRequest($uuid, $product, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalproductsUuidPatch'
     *
     * @param  string $uuid Product identifier (required)
     * @param  \OpenAPI\Client\Model\Product $product The updated Product resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalproductsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalproductsUuidPatchRequest($uuid, $product, string $contentType = self::contentTypes['apiApiInternalproductsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalproductsUuidPatch'
            );
        }

        // verify the required parameter 'product' is set
        if ($product === null || (is_array($product) && count($product) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $product when calling apiApiInternalproductsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/products/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($product)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($product));
            } else {
                $httpBody = $product;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaltenantsGetCollection
     *
     * Retrieves the collection of Tenant resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $probatix_customer_id  (optional)
     * @param  string[] $probatix_customer_id2  (optional)
     * @param  string $reporting_api_key  (optional)
     * @param  string[] $reporting_api_key2  (optional)
     * @param  string $base_url  (optional)
     * @param  string[] $base_url2  (optional)
     * @param  string $provider_key  (optional)
     * @param  string[] $provider_key2  (optional)
     * @param  string $deployment_stage  (optional)
     * @param  string[] $deployment_stage2  (optional)
     * @param  string $url_imprint  (optional)
     * @param  string[] $url_imprint2  (optional)
     * @param  string $url_homepage  (optional)
     * @param  string[] $url_homepage2  (optional)
     * @param  string $url_privacy  (optional)
     * @param  string[] $url_privacy2  (optional)
     * @param  string $provider_name  (optional)
     * @param  string[] $provider_name2  (optional)
     * @param  string $provider_address  (optional)
     * @param  string[] $provider_address2  (optional)
     * @param  string $provider_responsible_contact_name  (optional)
     * @param  string[] $provider_responsible_contact_name2  (optional)
     * @param  string $provider_data_privacy_contact  (optional)
     * @param  string[] $provider_data_privacy_contact2  (optional)
     * @param  string $provider_data_privacy_additional_information  (optional)
     * @param  string[] $provider_data_privacy_additional_information2  (optional)
     * @param  string $email_sender_address  (optional)
     * @param  string[] $email_sender_address2  (optional)
     * @param  string $provider_location_name  (optional)
     * @param  string[] $provider_location_name2  (optional)
     * @param  string $provider_location_registration_id  (optional)
     * @param  string[] $provider_location_registration_id2  (optional)
     * @param  string $provider_location_address  (optional)
     * @param  string[] $provider_location_address2  (optional)
     * @param  string $provider_location_phone  (optional)
     * @param  string[] $provider_location_phone2  (optional)
     * @param  string $provider_location_email  (optional)
     * @param  string[] $provider_location_email2  (optional)
     * @param  bool $is_booking_without_payment_allowed  (optional)
     * @param  bool[] $is_booking_without_payment_allowed2  (optional)
     * @param  bool $is_stripe_enabled  (optional)
     * @param  bool[] $is_stripe_enabled2  (optional)
     * @param  string $stripe_payment_methods  (optional)
     * @param  string[] $stripe_payment_methods2  (optional)
     * @param  string $stripe_account_id  (optional)
     * @param  string[] $stripe_account_id2  (optional)
     * @param  string $paypal_environment  (optional)
     * @param  string[] $paypal_environment2  (optional)
     * @param  bool $is_paypal_enabled  (optional)
     * @param  bool[] $is_paypal_enabled2  (optional)
     * @param  string $paypal_client_id  (optional)
     * @param  string[] $paypal_client_id2  (optional)
     * @param  string $paypal_client_secret  (optional)
     * @param  string[] $paypal_client_secret2  (optional)
     * @param  string $provider_test_details  (optional)
     * @param  string[] $provider_test_details2  (optional)
     * @param  int $provider_device_id_jrc_database  (optional)
     * @param  int[] $provider_device_id_jrc_database2  (optional)
     * @param  string $privacy_text  (optional)
     * @param  string[] $privacy_text2  (optional)
     * @param  bool $is_invoicing_enabled  (optional)
     * @param  bool[] $is_invoicing_enabled2  (optional)
     * @param  string $provider_url_logo  (optional)
     * @param  string[] $provider_url_logo2  (optional)
     * @param  string $general_terms_text  (optional)
     * @param  string[] $general_terms_text2  (optional)
     * @param  string $background_image_path  (optional)
     * @param  string[] $background_image_path2  (optional)
     * @param  string $logo_path  (optional)
     * @param  string[] $logo_path2  (optional)
     * @param  string $primary_color  (optional)
     * @param  string[] $primary_color2  (optional)
     * @param  string $secondary_color  (optional)
     * @param  string[] $secondary_color2  (optional)
     * @param  string $font_family  (optional)
     * @param  string[] $font_family2  (optional)
     * @param  string $header_font_family  (optional)
     * @param  string[] $header_font_family2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $punchline  (optional)
     * @param  string[] $punchline2  (optional)
     * @param  string $button_color  (optional)
     * @param  string[] $button_color2  (optional)
     * @param  bool $show_company_field_for_customers  (optional)
     * @param  bool[] $show_company_field_for_customers2  (optional)
     * @param  bool $attach_test_result  (optional)
     * @param  bool[] $attach_test_result2  (optional)
     * @param  string $list_of_companies_for_company_field_for_customers  (optional)
     * @param  string[] $list_of_companies_for_company_field_for_customers2  (optional)
     * @param  string $list_of_zip_codes_for_customers  (optional)
     * @param  string[] $list_of_zip_codes_for_customers2  (optional)
     * @param  bool $enable_availability_locations  (optional)
     * @param  bool[] $enable_availability_locations2  (optional)
     * @param  bool $mobile_scanning_enabled  (optional)
     * @param  bool[] $mobile_scanning_enabled2  (optional)
     * @param  bool $force_booking_slot_selection  (optional)
     * @param  bool[] $force_booking_slot_selection2  (optional)
     * @param  int $time_slot_duration  (optional)
     * @param  int[] $time_slot_duration2  (optional)
     * @param  int $duration_of_day_pass_validity  (optional)
     * @param  int[] $duration_of_day_pass_validity2  (optional)
     * @param  int $max_bookings_per_slot  (optional)
     * @param  int[] $max_bookings_per_slot2  (optional)
     * @param  int $opening_time  (optional)
     * @param  int[] $opening_time2  (optional)
     * @param  int $closing_time  (optional)
     * @param  int[] $closing_time2  (optional)
     * @param  bool $is_copy_availability_from_previous_week  (optional)
     * @param  bool[] $is_copy_availability_from_previous_week2  (optional)
     * @param  int $advance_booking_time_in_minutes  (optional)
     * @param  int[] $advance_booking_time_in_minutes2  (optional)
     * @param  int $editable_days  (optional)
     * @param  int[] $editable_days2  (optional)
     * @param  bool $my_probatix_enabled  (optional)
     * @param  bool[] $my_probatix_enabled2  (optional)
     * @param  string $my_probatix_client_id  (optional)
     * @param  string[] $my_probatix_client_id2  (optional)
     * @param  string $my_probatix_client_secret  (optional)
     * @param  string[] $my_probatix_client_secret2  (optional)
     * @param  int $internal_code_base  (optional)
     * @param  int[] $internal_code_base2  (optional)
     * @param  string $bsnr  (optional)
     * @param  string[] $bsnr2  (optional)
     * @param  string $tenant_selection_options  (optional)
     * @param  string[] $tenant_selection_options2  (optional)
     * @param  bool $send_invoice_automatically  (optional)
     * @param  bool[] $send_invoice_automatically2  (optional)
     * @param  string $test_producer  (optional)
     * @param  string[] $test_producer2  (optional)
     * @param  string $provider_street_and_house_number  (optional)
     * @param  string[] $provider_street_and_house_number2  (optional)
     * @param  string $provider_city  (optional)
     * @param  string[] $provider_city2  (optional)
     * @param  string $provider_zip_code  (optional)
     * @param  string[] $provider_zip_code2  (optional)
     * @param  string $provider_location_street_and_house_number  (optional)
     * @param  string[] $provider_location_street_and_house_number2  (optional)
     * @param  string $provider_location_city  (optional)
     * @param  string[] $provider_location_city2  (optional)
     * @param  string $provider_location_zip_code  (optional)
     * @param  string[] $provider_location_zip_code2  (optional)
     * @param  string $onboarding_step  (optional)
     * @param  string[] $onboarding_step2  (optional)
     * @param  string $printer_type  (optional)
     * @param  string[] $printer_type2  (optional)
     * @param  bool $show_test_paid_confirmation  (optional)
     * @param  bool[] $show_test_paid_confirmation2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  bool $show_available_slots  (optional)
     * @param  bool[] $show_available_slots2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $prefix  (optional)
     * @param  string[] $prefix2  (optional)
     * @param  bool $send_full_data_in_report_api  (optional)
     * @param  bool[] $send_full_data_in_report_api2  (optional)
     * @param  bool $is_availability_set_up  (optional)
     * @param  bool[] $is_availability_set_up2  (optional)
     * @param  bool $is_instance_cleared  (optional)
     * @param  bool[] $is_instance_cleared2  (optional)
     * @param  string $available_product_types  (optional)
     * @param  string[] $available_product_types2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tenant[]
     */
    public function apiApiInternaltenantsGetCollection($page = 1, $probatix_customer_id = null, $probatix_customer_id2 = null, $reporting_api_key = null, $reporting_api_key2 = null, $base_url = null, $base_url2 = null, $provider_key = null, $provider_key2 = null, $deployment_stage = null, $deployment_stage2 = null, $url_imprint = null, $url_imprint2 = null, $url_homepage = null, $url_homepage2 = null, $url_privacy = null, $url_privacy2 = null, $provider_name = null, $provider_name2 = null, $provider_address = null, $provider_address2 = null, $provider_responsible_contact_name = null, $provider_responsible_contact_name2 = null, $provider_data_privacy_contact = null, $provider_data_privacy_contact2 = null, $provider_data_privacy_additional_information = null, $provider_data_privacy_additional_information2 = null, $email_sender_address = null, $email_sender_address2 = null, $provider_location_name = null, $provider_location_name2 = null, $provider_location_registration_id = null, $provider_location_registration_id2 = null, $provider_location_address = null, $provider_location_address2 = null, $provider_location_phone = null, $provider_location_phone2 = null, $provider_location_email = null, $provider_location_email2 = null, $is_booking_without_payment_allowed = null, $is_booking_without_payment_allowed2 = null, $is_stripe_enabled = null, $is_stripe_enabled2 = null, $stripe_payment_methods = null, $stripe_payment_methods2 = null, $stripe_account_id = null, $stripe_account_id2 = null, $paypal_environment = null, $paypal_environment2 = null, $is_paypal_enabled = null, $is_paypal_enabled2 = null, $paypal_client_id = null, $paypal_client_id2 = null, $paypal_client_secret = null, $paypal_client_secret2 = null, $provider_test_details = null, $provider_test_details2 = null, $provider_device_id_jrc_database = null, $provider_device_id_jrc_database2 = null, $privacy_text = null, $privacy_text2 = null, $is_invoicing_enabled = null, $is_invoicing_enabled2 = null, $provider_url_logo = null, $provider_url_logo2 = null, $general_terms_text = null, $general_terms_text2 = null, $background_image_path = null, $background_image_path2 = null, $logo_path = null, $logo_path2 = null, $primary_color = null, $primary_color2 = null, $secondary_color = null, $secondary_color2 = null, $font_family = null, $font_family2 = null, $header_font_family = null, $header_font_family2 = null, $updated_at = null, $updated_at2 = null, $punchline = null, $punchline2 = null, $button_color = null, $button_color2 = null, $show_company_field_for_customers = null, $show_company_field_for_customers2 = null, $attach_test_result = null, $attach_test_result2 = null, $list_of_companies_for_company_field_for_customers = null, $list_of_companies_for_company_field_for_customers2 = null, $list_of_zip_codes_for_customers = null, $list_of_zip_codes_for_customers2 = null, $enable_availability_locations = null, $enable_availability_locations2 = null, $mobile_scanning_enabled = null, $mobile_scanning_enabled2 = null, $force_booking_slot_selection = null, $force_booking_slot_selection2 = null, $time_slot_duration = null, $time_slot_duration2 = null, $duration_of_day_pass_validity = null, $duration_of_day_pass_validity2 = null, $max_bookings_per_slot = null, $max_bookings_per_slot2 = null, $opening_time = null, $opening_time2 = null, $closing_time = null, $closing_time2 = null, $is_copy_availability_from_previous_week = null, $is_copy_availability_from_previous_week2 = null, $advance_booking_time_in_minutes = null, $advance_booking_time_in_minutes2 = null, $editable_days = null, $editable_days2 = null, $my_probatix_enabled = null, $my_probatix_enabled2 = null, $my_probatix_client_id = null, $my_probatix_client_id2 = null, $my_probatix_client_secret = null, $my_probatix_client_secret2 = null, $internal_code_base = null, $internal_code_base2 = null, $bsnr = null, $bsnr2 = null, $tenant_selection_options = null, $tenant_selection_options2 = null, $send_invoice_automatically = null, $send_invoice_automatically2 = null, $test_producer = null, $test_producer2 = null, $provider_street_and_house_number = null, $provider_street_and_house_number2 = null, $provider_city = null, $provider_city2 = null, $provider_zip_code = null, $provider_zip_code2 = null, $provider_location_street_and_house_number = null, $provider_location_street_and_house_number2 = null, $provider_location_city = null, $provider_location_city2 = null, $provider_location_zip_code = null, $provider_location_zip_code2 = null, $onboarding_step = null, $onboarding_step2 = null, $printer_type = null, $printer_type2 = null, $show_test_paid_confirmation = null, $show_test_paid_confirmation2 = null, $status = null, $status2 = null, $show_available_slots = null, $show_available_slots2 = null, $address_components = null, $address_components2 = null, $prefix = null, $prefix2 = null, $send_full_data_in_report_api = null, $send_full_data_in_report_api2 = null, $is_availability_set_up = null, $is_availability_set_up2 = null, $is_instance_cleared = null, $is_instance_cleared2 = null, $available_product_types = null, $available_product_types2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaltenantsGetCollection'][0])
    {
        list($response) = $this->apiApiInternaltenantsGetCollectionWithHttpInfo($page, $probatix_customer_id, $probatix_customer_id2, $reporting_api_key, $reporting_api_key2, $base_url, $base_url2, $provider_key, $provider_key2, $deployment_stage, $deployment_stage2, $url_imprint, $url_imprint2, $url_homepage, $url_homepage2, $url_privacy, $url_privacy2, $provider_name, $provider_name2, $provider_address, $provider_address2, $provider_responsible_contact_name, $provider_responsible_contact_name2, $provider_data_privacy_contact, $provider_data_privacy_contact2, $provider_data_privacy_additional_information, $provider_data_privacy_additional_information2, $email_sender_address, $email_sender_address2, $provider_location_name, $provider_location_name2, $provider_location_registration_id, $provider_location_registration_id2, $provider_location_address, $provider_location_address2, $provider_location_phone, $provider_location_phone2, $provider_location_email, $provider_location_email2, $is_booking_without_payment_allowed, $is_booking_without_payment_allowed2, $is_stripe_enabled, $is_stripe_enabled2, $stripe_payment_methods, $stripe_payment_methods2, $stripe_account_id, $stripe_account_id2, $paypal_environment, $paypal_environment2, $is_paypal_enabled, $is_paypal_enabled2, $paypal_client_id, $paypal_client_id2, $paypal_client_secret, $paypal_client_secret2, $provider_test_details, $provider_test_details2, $provider_device_id_jrc_database, $provider_device_id_jrc_database2, $privacy_text, $privacy_text2, $is_invoicing_enabled, $is_invoicing_enabled2, $provider_url_logo, $provider_url_logo2, $general_terms_text, $general_terms_text2, $background_image_path, $background_image_path2, $logo_path, $logo_path2, $primary_color, $primary_color2, $secondary_color, $secondary_color2, $font_family, $font_family2, $header_font_family, $header_font_family2, $updated_at, $updated_at2, $punchline, $punchline2, $button_color, $button_color2, $show_company_field_for_customers, $show_company_field_for_customers2, $attach_test_result, $attach_test_result2, $list_of_companies_for_company_field_for_customers, $list_of_companies_for_company_field_for_customers2, $list_of_zip_codes_for_customers, $list_of_zip_codes_for_customers2, $enable_availability_locations, $enable_availability_locations2, $mobile_scanning_enabled, $mobile_scanning_enabled2, $force_booking_slot_selection, $force_booking_slot_selection2, $time_slot_duration, $time_slot_duration2, $duration_of_day_pass_validity, $duration_of_day_pass_validity2, $max_bookings_per_slot, $max_bookings_per_slot2, $opening_time, $opening_time2, $closing_time, $closing_time2, $is_copy_availability_from_previous_week, $is_copy_availability_from_previous_week2, $advance_booking_time_in_minutes, $advance_booking_time_in_minutes2, $editable_days, $editable_days2, $my_probatix_enabled, $my_probatix_enabled2, $my_probatix_client_id, $my_probatix_client_id2, $my_probatix_client_secret, $my_probatix_client_secret2, $internal_code_base, $internal_code_base2, $bsnr, $bsnr2, $tenant_selection_options, $tenant_selection_options2, $send_invoice_automatically, $send_invoice_automatically2, $test_producer, $test_producer2, $provider_street_and_house_number, $provider_street_and_house_number2, $provider_city, $provider_city2, $provider_zip_code, $provider_zip_code2, $provider_location_street_and_house_number, $provider_location_street_and_house_number2, $provider_location_city, $provider_location_city2, $provider_location_zip_code, $provider_location_zip_code2, $onboarding_step, $onboarding_step2, $printer_type, $printer_type2, $show_test_paid_confirmation, $show_test_paid_confirmation2, $status, $status2, $show_available_slots, $show_available_slots2, $address_components, $address_components2, $prefix, $prefix2, $send_full_data_in_report_api, $send_full_data_in_report_api2, $is_availability_set_up, $is_availability_set_up2, $is_instance_cleared, $is_instance_cleared2, $available_product_types, $available_product_types2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaltenantsGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Tenant resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $probatix_customer_id  (optional)
     * @param  string[] $probatix_customer_id2  (optional)
     * @param  string $reporting_api_key  (optional)
     * @param  string[] $reporting_api_key2  (optional)
     * @param  string $base_url  (optional)
     * @param  string[] $base_url2  (optional)
     * @param  string $provider_key  (optional)
     * @param  string[] $provider_key2  (optional)
     * @param  string $deployment_stage  (optional)
     * @param  string[] $deployment_stage2  (optional)
     * @param  string $url_imprint  (optional)
     * @param  string[] $url_imprint2  (optional)
     * @param  string $url_homepage  (optional)
     * @param  string[] $url_homepage2  (optional)
     * @param  string $url_privacy  (optional)
     * @param  string[] $url_privacy2  (optional)
     * @param  string $provider_name  (optional)
     * @param  string[] $provider_name2  (optional)
     * @param  string $provider_address  (optional)
     * @param  string[] $provider_address2  (optional)
     * @param  string $provider_responsible_contact_name  (optional)
     * @param  string[] $provider_responsible_contact_name2  (optional)
     * @param  string $provider_data_privacy_contact  (optional)
     * @param  string[] $provider_data_privacy_contact2  (optional)
     * @param  string $provider_data_privacy_additional_information  (optional)
     * @param  string[] $provider_data_privacy_additional_information2  (optional)
     * @param  string $email_sender_address  (optional)
     * @param  string[] $email_sender_address2  (optional)
     * @param  string $provider_location_name  (optional)
     * @param  string[] $provider_location_name2  (optional)
     * @param  string $provider_location_registration_id  (optional)
     * @param  string[] $provider_location_registration_id2  (optional)
     * @param  string $provider_location_address  (optional)
     * @param  string[] $provider_location_address2  (optional)
     * @param  string $provider_location_phone  (optional)
     * @param  string[] $provider_location_phone2  (optional)
     * @param  string $provider_location_email  (optional)
     * @param  string[] $provider_location_email2  (optional)
     * @param  bool $is_booking_without_payment_allowed  (optional)
     * @param  bool[] $is_booking_without_payment_allowed2  (optional)
     * @param  bool $is_stripe_enabled  (optional)
     * @param  bool[] $is_stripe_enabled2  (optional)
     * @param  string $stripe_payment_methods  (optional)
     * @param  string[] $stripe_payment_methods2  (optional)
     * @param  string $stripe_account_id  (optional)
     * @param  string[] $stripe_account_id2  (optional)
     * @param  string $paypal_environment  (optional)
     * @param  string[] $paypal_environment2  (optional)
     * @param  bool $is_paypal_enabled  (optional)
     * @param  bool[] $is_paypal_enabled2  (optional)
     * @param  string $paypal_client_id  (optional)
     * @param  string[] $paypal_client_id2  (optional)
     * @param  string $paypal_client_secret  (optional)
     * @param  string[] $paypal_client_secret2  (optional)
     * @param  string $provider_test_details  (optional)
     * @param  string[] $provider_test_details2  (optional)
     * @param  int $provider_device_id_jrc_database  (optional)
     * @param  int[] $provider_device_id_jrc_database2  (optional)
     * @param  string $privacy_text  (optional)
     * @param  string[] $privacy_text2  (optional)
     * @param  bool $is_invoicing_enabled  (optional)
     * @param  bool[] $is_invoicing_enabled2  (optional)
     * @param  string $provider_url_logo  (optional)
     * @param  string[] $provider_url_logo2  (optional)
     * @param  string $general_terms_text  (optional)
     * @param  string[] $general_terms_text2  (optional)
     * @param  string $background_image_path  (optional)
     * @param  string[] $background_image_path2  (optional)
     * @param  string $logo_path  (optional)
     * @param  string[] $logo_path2  (optional)
     * @param  string $primary_color  (optional)
     * @param  string[] $primary_color2  (optional)
     * @param  string $secondary_color  (optional)
     * @param  string[] $secondary_color2  (optional)
     * @param  string $font_family  (optional)
     * @param  string[] $font_family2  (optional)
     * @param  string $header_font_family  (optional)
     * @param  string[] $header_font_family2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $punchline  (optional)
     * @param  string[] $punchline2  (optional)
     * @param  string $button_color  (optional)
     * @param  string[] $button_color2  (optional)
     * @param  bool $show_company_field_for_customers  (optional)
     * @param  bool[] $show_company_field_for_customers2  (optional)
     * @param  bool $attach_test_result  (optional)
     * @param  bool[] $attach_test_result2  (optional)
     * @param  string $list_of_companies_for_company_field_for_customers  (optional)
     * @param  string[] $list_of_companies_for_company_field_for_customers2  (optional)
     * @param  string $list_of_zip_codes_for_customers  (optional)
     * @param  string[] $list_of_zip_codes_for_customers2  (optional)
     * @param  bool $enable_availability_locations  (optional)
     * @param  bool[] $enable_availability_locations2  (optional)
     * @param  bool $mobile_scanning_enabled  (optional)
     * @param  bool[] $mobile_scanning_enabled2  (optional)
     * @param  bool $force_booking_slot_selection  (optional)
     * @param  bool[] $force_booking_slot_selection2  (optional)
     * @param  int $time_slot_duration  (optional)
     * @param  int[] $time_slot_duration2  (optional)
     * @param  int $duration_of_day_pass_validity  (optional)
     * @param  int[] $duration_of_day_pass_validity2  (optional)
     * @param  int $max_bookings_per_slot  (optional)
     * @param  int[] $max_bookings_per_slot2  (optional)
     * @param  int $opening_time  (optional)
     * @param  int[] $opening_time2  (optional)
     * @param  int $closing_time  (optional)
     * @param  int[] $closing_time2  (optional)
     * @param  bool $is_copy_availability_from_previous_week  (optional)
     * @param  bool[] $is_copy_availability_from_previous_week2  (optional)
     * @param  int $advance_booking_time_in_minutes  (optional)
     * @param  int[] $advance_booking_time_in_minutes2  (optional)
     * @param  int $editable_days  (optional)
     * @param  int[] $editable_days2  (optional)
     * @param  bool $my_probatix_enabled  (optional)
     * @param  bool[] $my_probatix_enabled2  (optional)
     * @param  string $my_probatix_client_id  (optional)
     * @param  string[] $my_probatix_client_id2  (optional)
     * @param  string $my_probatix_client_secret  (optional)
     * @param  string[] $my_probatix_client_secret2  (optional)
     * @param  int $internal_code_base  (optional)
     * @param  int[] $internal_code_base2  (optional)
     * @param  string $bsnr  (optional)
     * @param  string[] $bsnr2  (optional)
     * @param  string $tenant_selection_options  (optional)
     * @param  string[] $tenant_selection_options2  (optional)
     * @param  bool $send_invoice_automatically  (optional)
     * @param  bool[] $send_invoice_automatically2  (optional)
     * @param  string $test_producer  (optional)
     * @param  string[] $test_producer2  (optional)
     * @param  string $provider_street_and_house_number  (optional)
     * @param  string[] $provider_street_and_house_number2  (optional)
     * @param  string $provider_city  (optional)
     * @param  string[] $provider_city2  (optional)
     * @param  string $provider_zip_code  (optional)
     * @param  string[] $provider_zip_code2  (optional)
     * @param  string $provider_location_street_and_house_number  (optional)
     * @param  string[] $provider_location_street_and_house_number2  (optional)
     * @param  string $provider_location_city  (optional)
     * @param  string[] $provider_location_city2  (optional)
     * @param  string $provider_location_zip_code  (optional)
     * @param  string[] $provider_location_zip_code2  (optional)
     * @param  string $onboarding_step  (optional)
     * @param  string[] $onboarding_step2  (optional)
     * @param  string $printer_type  (optional)
     * @param  string[] $printer_type2  (optional)
     * @param  bool $show_test_paid_confirmation  (optional)
     * @param  bool[] $show_test_paid_confirmation2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  bool $show_available_slots  (optional)
     * @param  bool[] $show_available_slots2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $prefix  (optional)
     * @param  string[] $prefix2  (optional)
     * @param  bool $send_full_data_in_report_api  (optional)
     * @param  bool[] $send_full_data_in_report_api2  (optional)
     * @param  bool $is_availability_set_up  (optional)
     * @param  bool[] $is_availability_set_up2  (optional)
     * @param  bool $is_instance_cleared  (optional)
     * @param  bool[] $is_instance_cleared2  (optional)
     * @param  string $available_product_types  (optional)
     * @param  string[] $available_product_types2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tenant[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaltenantsGetCollectionWithHttpInfo($page = 1, $probatix_customer_id = null, $probatix_customer_id2 = null, $reporting_api_key = null, $reporting_api_key2 = null, $base_url = null, $base_url2 = null, $provider_key = null, $provider_key2 = null, $deployment_stage = null, $deployment_stage2 = null, $url_imprint = null, $url_imprint2 = null, $url_homepage = null, $url_homepage2 = null, $url_privacy = null, $url_privacy2 = null, $provider_name = null, $provider_name2 = null, $provider_address = null, $provider_address2 = null, $provider_responsible_contact_name = null, $provider_responsible_contact_name2 = null, $provider_data_privacy_contact = null, $provider_data_privacy_contact2 = null, $provider_data_privacy_additional_information = null, $provider_data_privacy_additional_information2 = null, $email_sender_address = null, $email_sender_address2 = null, $provider_location_name = null, $provider_location_name2 = null, $provider_location_registration_id = null, $provider_location_registration_id2 = null, $provider_location_address = null, $provider_location_address2 = null, $provider_location_phone = null, $provider_location_phone2 = null, $provider_location_email = null, $provider_location_email2 = null, $is_booking_without_payment_allowed = null, $is_booking_without_payment_allowed2 = null, $is_stripe_enabled = null, $is_stripe_enabled2 = null, $stripe_payment_methods = null, $stripe_payment_methods2 = null, $stripe_account_id = null, $stripe_account_id2 = null, $paypal_environment = null, $paypal_environment2 = null, $is_paypal_enabled = null, $is_paypal_enabled2 = null, $paypal_client_id = null, $paypal_client_id2 = null, $paypal_client_secret = null, $paypal_client_secret2 = null, $provider_test_details = null, $provider_test_details2 = null, $provider_device_id_jrc_database = null, $provider_device_id_jrc_database2 = null, $privacy_text = null, $privacy_text2 = null, $is_invoicing_enabled = null, $is_invoicing_enabled2 = null, $provider_url_logo = null, $provider_url_logo2 = null, $general_terms_text = null, $general_terms_text2 = null, $background_image_path = null, $background_image_path2 = null, $logo_path = null, $logo_path2 = null, $primary_color = null, $primary_color2 = null, $secondary_color = null, $secondary_color2 = null, $font_family = null, $font_family2 = null, $header_font_family = null, $header_font_family2 = null, $updated_at = null, $updated_at2 = null, $punchline = null, $punchline2 = null, $button_color = null, $button_color2 = null, $show_company_field_for_customers = null, $show_company_field_for_customers2 = null, $attach_test_result = null, $attach_test_result2 = null, $list_of_companies_for_company_field_for_customers = null, $list_of_companies_for_company_field_for_customers2 = null, $list_of_zip_codes_for_customers = null, $list_of_zip_codes_for_customers2 = null, $enable_availability_locations = null, $enable_availability_locations2 = null, $mobile_scanning_enabled = null, $mobile_scanning_enabled2 = null, $force_booking_slot_selection = null, $force_booking_slot_selection2 = null, $time_slot_duration = null, $time_slot_duration2 = null, $duration_of_day_pass_validity = null, $duration_of_day_pass_validity2 = null, $max_bookings_per_slot = null, $max_bookings_per_slot2 = null, $opening_time = null, $opening_time2 = null, $closing_time = null, $closing_time2 = null, $is_copy_availability_from_previous_week = null, $is_copy_availability_from_previous_week2 = null, $advance_booking_time_in_minutes = null, $advance_booking_time_in_minutes2 = null, $editable_days = null, $editable_days2 = null, $my_probatix_enabled = null, $my_probatix_enabled2 = null, $my_probatix_client_id = null, $my_probatix_client_id2 = null, $my_probatix_client_secret = null, $my_probatix_client_secret2 = null, $internal_code_base = null, $internal_code_base2 = null, $bsnr = null, $bsnr2 = null, $tenant_selection_options = null, $tenant_selection_options2 = null, $send_invoice_automatically = null, $send_invoice_automatically2 = null, $test_producer = null, $test_producer2 = null, $provider_street_and_house_number = null, $provider_street_and_house_number2 = null, $provider_city = null, $provider_city2 = null, $provider_zip_code = null, $provider_zip_code2 = null, $provider_location_street_and_house_number = null, $provider_location_street_and_house_number2 = null, $provider_location_city = null, $provider_location_city2 = null, $provider_location_zip_code = null, $provider_location_zip_code2 = null, $onboarding_step = null, $onboarding_step2 = null, $printer_type = null, $printer_type2 = null, $show_test_paid_confirmation = null, $show_test_paid_confirmation2 = null, $status = null, $status2 = null, $show_available_slots = null, $show_available_slots2 = null, $address_components = null, $address_components2 = null, $prefix = null, $prefix2 = null, $send_full_data_in_report_api = null, $send_full_data_in_report_api2 = null, $is_availability_set_up = null, $is_availability_set_up2 = null, $is_instance_cleared = null, $is_instance_cleared2 = null, $available_product_types = null, $available_product_types2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaltenantsGetCollection'][0])
    {
        $request = $this->apiApiInternaltenantsGetCollectionRequest($page, $probatix_customer_id, $probatix_customer_id2, $reporting_api_key, $reporting_api_key2, $base_url, $base_url2, $provider_key, $provider_key2, $deployment_stage, $deployment_stage2, $url_imprint, $url_imprint2, $url_homepage, $url_homepage2, $url_privacy, $url_privacy2, $provider_name, $provider_name2, $provider_address, $provider_address2, $provider_responsible_contact_name, $provider_responsible_contact_name2, $provider_data_privacy_contact, $provider_data_privacy_contact2, $provider_data_privacy_additional_information, $provider_data_privacy_additional_information2, $email_sender_address, $email_sender_address2, $provider_location_name, $provider_location_name2, $provider_location_registration_id, $provider_location_registration_id2, $provider_location_address, $provider_location_address2, $provider_location_phone, $provider_location_phone2, $provider_location_email, $provider_location_email2, $is_booking_without_payment_allowed, $is_booking_without_payment_allowed2, $is_stripe_enabled, $is_stripe_enabled2, $stripe_payment_methods, $stripe_payment_methods2, $stripe_account_id, $stripe_account_id2, $paypal_environment, $paypal_environment2, $is_paypal_enabled, $is_paypal_enabled2, $paypal_client_id, $paypal_client_id2, $paypal_client_secret, $paypal_client_secret2, $provider_test_details, $provider_test_details2, $provider_device_id_jrc_database, $provider_device_id_jrc_database2, $privacy_text, $privacy_text2, $is_invoicing_enabled, $is_invoicing_enabled2, $provider_url_logo, $provider_url_logo2, $general_terms_text, $general_terms_text2, $background_image_path, $background_image_path2, $logo_path, $logo_path2, $primary_color, $primary_color2, $secondary_color, $secondary_color2, $font_family, $font_family2, $header_font_family, $header_font_family2, $updated_at, $updated_at2, $punchline, $punchline2, $button_color, $button_color2, $show_company_field_for_customers, $show_company_field_for_customers2, $attach_test_result, $attach_test_result2, $list_of_companies_for_company_field_for_customers, $list_of_companies_for_company_field_for_customers2, $list_of_zip_codes_for_customers, $list_of_zip_codes_for_customers2, $enable_availability_locations, $enable_availability_locations2, $mobile_scanning_enabled, $mobile_scanning_enabled2, $force_booking_slot_selection, $force_booking_slot_selection2, $time_slot_duration, $time_slot_duration2, $duration_of_day_pass_validity, $duration_of_day_pass_validity2, $max_bookings_per_slot, $max_bookings_per_slot2, $opening_time, $opening_time2, $closing_time, $closing_time2, $is_copy_availability_from_previous_week, $is_copy_availability_from_previous_week2, $advance_booking_time_in_minutes, $advance_booking_time_in_minutes2, $editable_days, $editable_days2, $my_probatix_enabled, $my_probatix_enabled2, $my_probatix_client_id, $my_probatix_client_id2, $my_probatix_client_secret, $my_probatix_client_secret2, $internal_code_base, $internal_code_base2, $bsnr, $bsnr2, $tenant_selection_options, $tenant_selection_options2, $send_invoice_automatically, $send_invoice_automatically2, $test_producer, $test_producer2, $provider_street_and_house_number, $provider_street_and_house_number2, $provider_city, $provider_city2, $provider_zip_code, $provider_zip_code2, $provider_location_street_and_house_number, $provider_location_street_and_house_number2, $provider_location_city, $provider_location_city2, $provider_location_zip_code, $provider_location_zip_code2, $onboarding_step, $onboarding_step2, $printer_type, $printer_type2, $show_test_paid_confirmation, $show_test_paid_confirmation2, $status, $status2, $show_available_slots, $show_available_slots2, $address_components, $address_components2, $prefix, $prefix2, $send_full_data_in_report_api, $send_full_data_in_report_api2, $is_availability_set_up, $is_availability_set_up2, $is_instance_cleared, $is_instance_cleared2, $available_product_types, $available_product_types2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tenant[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tenant[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tenant[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tenant[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tenant[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaltenantsGetCollectionAsync
     *
     * Retrieves the collection of Tenant resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $probatix_customer_id  (optional)
     * @param  string[] $probatix_customer_id2  (optional)
     * @param  string $reporting_api_key  (optional)
     * @param  string[] $reporting_api_key2  (optional)
     * @param  string $base_url  (optional)
     * @param  string[] $base_url2  (optional)
     * @param  string $provider_key  (optional)
     * @param  string[] $provider_key2  (optional)
     * @param  string $deployment_stage  (optional)
     * @param  string[] $deployment_stage2  (optional)
     * @param  string $url_imprint  (optional)
     * @param  string[] $url_imprint2  (optional)
     * @param  string $url_homepage  (optional)
     * @param  string[] $url_homepage2  (optional)
     * @param  string $url_privacy  (optional)
     * @param  string[] $url_privacy2  (optional)
     * @param  string $provider_name  (optional)
     * @param  string[] $provider_name2  (optional)
     * @param  string $provider_address  (optional)
     * @param  string[] $provider_address2  (optional)
     * @param  string $provider_responsible_contact_name  (optional)
     * @param  string[] $provider_responsible_contact_name2  (optional)
     * @param  string $provider_data_privacy_contact  (optional)
     * @param  string[] $provider_data_privacy_contact2  (optional)
     * @param  string $provider_data_privacy_additional_information  (optional)
     * @param  string[] $provider_data_privacy_additional_information2  (optional)
     * @param  string $email_sender_address  (optional)
     * @param  string[] $email_sender_address2  (optional)
     * @param  string $provider_location_name  (optional)
     * @param  string[] $provider_location_name2  (optional)
     * @param  string $provider_location_registration_id  (optional)
     * @param  string[] $provider_location_registration_id2  (optional)
     * @param  string $provider_location_address  (optional)
     * @param  string[] $provider_location_address2  (optional)
     * @param  string $provider_location_phone  (optional)
     * @param  string[] $provider_location_phone2  (optional)
     * @param  string $provider_location_email  (optional)
     * @param  string[] $provider_location_email2  (optional)
     * @param  bool $is_booking_without_payment_allowed  (optional)
     * @param  bool[] $is_booking_without_payment_allowed2  (optional)
     * @param  bool $is_stripe_enabled  (optional)
     * @param  bool[] $is_stripe_enabled2  (optional)
     * @param  string $stripe_payment_methods  (optional)
     * @param  string[] $stripe_payment_methods2  (optional)
     * @param  string $stripe_account_id  (optional)
     * @param  string[] $stripe_account_id2  (optional)
     * @param  string $paypal_environment  (optional)
     * @param  string[] $paypal_environment2  (optional)
     * @param  bool $is_paypal_enabled  (optional)
     * @param  bool[] $is_paypal_enabled2  (optional)
     * @param  string $paypal_client_id  (optional)
     * @param  string[] $paypal_client_id2  (optional)
     * @param  string $paypal_client_secret  (optional)
     * @param  string[] $paypal_client_secret2  (optional)
     * @param  string $provider_test_details  (optional)
     * @param  string[] $provider_test_details2  (optional)
     * @param  int $provider_device_id_jrc_database  (optional)
     * @param  int[] $provider_device_id_jrc_database2  (optional)
     * @param  string $privacy_text  (optional)
     * @param  string[] $privacy_text2  (optional)
     * @param  bool $is_invoicing_enabled  (optional)
     * @param  bool[] $is_invoicing_enabled2  (optional)
     * @param  string $provider_url_logo  (optional)
     * @param  string[] $provider_url_logo2  (optional)
     * @param  string $general_terms_text  (optional)
     * @param  string[] $general_terms_text2  (optional)
     * @param  string $background_image_path  (optional)
     * @param  string[] $background_image_path2  (optional)
     * @param  string $logo_path  (optional)
     * @param  string[] $logo_path2  (optional)
     * @param  string $primary_color  (optional)
     * @param  string[] $primary_color2  (optional)
     * @param  string $secondary_color  (optional)
     * @param  string[] $secondary_color2  (optional)
     * @param  string $font_family  (optional)
     * @param  string[] $font_family2  (optional)
     * @param  string $header_font_family  (optional)
     * @param  string[] $header_font_family2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $punchline  (optional)
     * @param  string[] $punchline2  (optional)
     * @param  string $button_color  (optional)
     * @param  string[] $button_color2  (optional)
     * @param  bool $show_company_field_for_customers  (optional)
     * @param  bool[] $show_company_field_for_customers2  (optional)
     * @param  bool $attach_test_result  (optional)
     * @param  bool[] $attach_test_result2  (optional)
     * @param  string $list_of_companies_for_company_field_for_customers  (optional)
     * @param  string[] $list_of_companies_for_company_field_for_customers2  (optional)
     * @param  string $list_of_zip_codes_for_customers  (optional)
     * @param  string[] $list_of_zip_codes_for_customers2  (optional)
     * @param  bool $enable_availability_locations  (optional)
     * @param  bool[] $enable_availability_locations2  (optional)
     * @param  bool $mobile_scanning_enabled  (optional)
     * @param  bool[] $mobile_scanning_enabled2  (optional)
     * @param  bool $force_booking_slot_selection  (optional)
     * @param  bool[] $force_booking_slot_selection2  (optional)
     * @param  int $time_slot_duration  (optional)
     * @param  int[] $time_slot_duration2  (optional)
     * @param  int $duration_of_day_pass_validity  (optional)
     * @param  int[] $duration_of_day_pass_validity2  (optional)
     * @param  int $max_bookings_per_slot  (optional)
     * @param  int[] $max_bookings_per_slot2  (optional)
     * @param  int $opening_time  (optional)
     * @param  int[] $opening_time2  (optional)
     * @param  int $closing_time  (optional)
     * @param  int[] $closing_time2  (optional)
     * @param  bool $is_copy_availability_from_previous_week  (optional)
     * @param  bool[] $is_copy_availability_from_previous_week2  (optional)
     * @param  int $advance_booking_time_in_minutes  (optional)
     * @param  int[] $advance_booking_time_in_minutes2  (optional)
     * @param  int $editable_days  (optional)
     * @param  int[] $editable_days2  (optional)
     * @param  bool $my_probatix_enabled  (optional)
     * @param  bool[] $my_probatix_enabled2  (optional)
     * @param  string $my_probatix_client_id  (optional)
     * @param  string[] $my_probatix_client_id2  (optional)
     * @param  string $my_probatix_client_secret  (optional)
     * @param  string[] $my_probatix_client_secret2  (optional)
     * @param  int $internal_code_base  (optional)
     * @param  int[] $internal_code_base2  (optional)
     * @param  string $bsnr  (optional)
     * @param  string[] $bsnr2  (optional)
     * @param  string $tenant_selection_options  (optional)
     * @param  string[] $tenant_selection_options2  (optional)
     * @param  bool $send_invoice_automatically  (optional)
     * @param  bool[] $send_invoice_automatically2  (optional)
     * @param  string $test_producer  (optional)
     * @param  string[] $test_producer2  (optional)
     * @param  string $provider_street_and_house_number  (optional)
     * @param  string[] $provider_street_and_house_number2  (optional)
     * @param  string $provider_city  (optional)
     * @param  string[] $provider_city2  (optional)
     * @param  string $provider_zip_code  (optional)
     * @param  string[] $provider_zip_code2  (optional)
     * @param  string $provider_location_street_and_house_number  (optional)
     * @param  string[] $provider_location_street_and_house_number2  (optional)
     * @param  string $provider_location_city  (optional)
     * @param  string[] $provider_location_city2  (optional)
     * @param  string $provider_location_zip_code  (optional)
     * @param  string[] $provider_location_zip_code2  (optional)
     * @param  string $onboarding_step  (optional)
     * @param  string[] $onboarding_step2  (optional)
     * @param  string $printer_type  (optional)
     * @param  string[] $printer_type2  (optional)
     * @param  bool $show_test_paid_confirmation  (optional)
     * @param  bool[] $show_test_paid_confirmation2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  bool $show_available_slots  (optional)
     * @param  bool[] $show_available_slots2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $prefix  (optional)
     * @param  string[] $prefix2  (optional)
     * @param  bool $send_full_data_in_report_api  (optional)
     * @param  bool[] $send_full_data_in_report_api2  (optional)
     * @param  bool $is_availability_set_up  (optional)
     * @param  bool[] $is_availability_set_up2  (optional)
     * @param  bool $is_instance_cleared  (optional)
     * @param  bool[] $is_instance_cleared2  (optional)
     * @param  string $available_product_types  (optional)
     * @param  string[] $available_product_types2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsGetCollectionAsync($page = 1, $probatix_customer_id = null, $probatix_customer_id2 = null, $reporting_api_key = null, $reporting_api_key2 = null, $base_url = null, $base_url2 = null, $provider_key = null, $provider_key2 = null, $deployment_stage = null, $deployment_stage2 = null, $url_imprint = null, $url_imprint2 = null, $url_homepage = null, $url_homepage2 = null, $url_privacy = null, $url_privacy2 = null, $provider_name = null, $provider_name2 = null, $provider_address = null, $provider_address2 = null, $provider_responsible_contact_name = null, $provider_responsible_contact_name2 = null, $provider_data_privacy_contact = null, $provider_data_privacy_contact2 = null, $provider_data_privacy_additional_information = null, $provider_data_privacy_additional_information2 = null, $email_sender_address = null, $email_sender_address2 = null, $provider_location_name = null, $provider_location_name2 = null, $provider_location_registration_id = null, $provider_location_registration_id2 = null, $provider_location_address = null, $provider_location_address2 = null, $provider_location_phone = null, $provider_location_phone2 = null, $provider_location_email = null, $provider_location_email2 = null, $is_booking_without_payment_allowed = null, $is_booking_without_payment_allowed2 = null, $is_stripe_enabled = null, $is_stripe_enabled2 = null, $stripe_payment_methods = null, $stripe_payment_methods2 = null, $stripe_account_id = null, $stripe_account_id2 = null, $paypal_environment = null, $paypal_environment2 = null, $is_paypal_enabled = null, $is_paypal_enabled2 = null, $paypal_client_id = null, $paypal_client_id2 = null, $paypal_client_secret = null, $paypal_client_secret2 = null, $provider_test_details = null, $provider_test_details2 = null, $provider_device_id_jrc_database = null, $provider_device_id_jrc_database2 = null, $privacy_text = null, $privacy_text2 = null, $is_invoicing_enabled = null, $is_invoicing_enabled2 = null, $provider_url_logo = null, $provider_url_logo2 = null, $general_terms_text = null, $general_terms_text2 = null, $background_image_path = null, $background_image_path2 = null, $logo_path = null, $logo_path2 = null, $primary_color = null, $primary_color2 = null, $secondary_color = null, $secondary_color2 = null, $font_family = null, $font_family2 = null, $header_font_family = null, $header_font_family2 = null, $updated_at = null, $updated_at2 = null, $punchline = null, $punchline2 = null, $button_color = null, $button_color2 = null, $show_company_field_for_customers = null, $show_company_field_for_customers2 = null, $attach_test_result = null, $attach_test_result2 = null, $list_of_companies_for_company_field_for_customers = null, $list_of_companies_for_company_field_for_customers2 = null, $list_of_zip_codes_for_customers = null, $list_of_zip_codes_for_customers2 = null, $enable_availability_locations = null, $enable_availability_locations2 = null, $mobile_scanning_enabled = null, $mobile_scanning_enabled2 = null, $force_booking_slot_selection = null, $force_booking_slot_selection2 = null, $time_slot_duration = null, $time_slot_duration2 = null, $duration_of_day_pass_validity = null, $duration_of_day_pass_validity2 = null, $max_bookings_per_slot = null, $max_bookings_per_slot2 = null, $opening_time = null, $opening_time2 = null, $closing_time = null, $closing_time2 = null, $is_copy_availability_from_previous_week = null, $is_copy_availability_from_previous_week2 = null, $advance_booking_time_in_minutes = null, $advance_booking_time_in_minutes2 = null, $editable_days = null, $editable_days2 = null, $my_probatix_enabled = null, $my_probatix_enabled2 = null, $my_probatix_client_id = null, $my_probatix_client_id2 = null, $my_probatix_client_secret = null, $my_probatix_client_secret2 = null, $internal_code_base = null, $internal_code_base2 = null, $bsnr = null, $bsnr2 = null, $tenant_selection_options = null, $tenant_selection_options2 = null, $send_invoice_automatically = null, $send_invoice_automatically2 = null, $test_producer = null, $test_producer2 = null, $provider_street_and_house_number = null, $provider_street_and_house_number2 = null, $provider_city = null, $provider_city2 = null, $provider_zip_code = null, $provider_zip_code2 = null, $provider_location_street_and_house_number = null, $provider_location_street_and_house_number2 = null, $provider_location_city = null, $provider_location_city2 = null, $provider_location_zip_code = null, $provider_location_zip_code2 = null, $onboarding_step = null, $onboarding_step2 = null, $printer_type = null, $printer_type2 = null, $show_test_paid_confirmation = null, $show_test_paid_confirmation2 = null, $status = null, $status2 = null, $show_available_slots = null, $show_available_slots2 = null, $address_components = null, $address_components2 = null, $prefix = null, $prefix2 = null, $send_full_data_in_report_api = null, $send_full_data_in_report_api2 = null, $is_availability_set_up = null, $is_availability_set_up2 = null, $is_instance_cleared = null, $is_instance_cleared2 = null, $available_product_types = null, $available_product_types2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaltenantsGetCollection'][0])
    {
        return $this->apiApiInternaltenantsGetCollectionAsyncWithHttpInfo($page, $probatix_customer_id, $probatix_customer_id2, $reporting_api_key, $reporting_api_key2, $base_url, $base_url2, $provider_key, $provider_key2, $deployment_stage, $deployment_stage2, $url_imprint, $url_imprint2, $url_homepage, $url_homepage2, $url_privacy, $url_privacy2, $provider_name, $provider_name2, $provider_address, $provider_address2, $provider_responsible_contact_name, $provider_responsible_contact_name2, $provider_data_privacy_contact, $provider_data_privacy_contact2, $provider_data_privacy_additional_information, $provider_data_privacy_additional_information2, $email_sender_address, $email_sender_address2, $provider_location_name, $provider_location_name2, $provider_location_registration_id, $provider_location_registration_id2, $provider_location_address, $provider_location_address2, $provider_location_phone, $provider_location_phone2, $provider_location_email, $provider_location_email2, $is_booking_without_payment_allowed, $is_booking_without_payment_allowed2, $is_stripe_enabled, $is_stripe_enabled2, $stripe_payment_methods, $stripe_payment_methods2, $stripe_account_id, $stripe_account_id2, $paypal_environment, $paypal_environment2, $is_paypal_enabled, $is_paypal_enabled2, $paypal_client_id, $paypal_client_id2, $paypal_client_secret, $paypal_client_secret2, $provider_test_details, $provider_test_details2, $provider_device_id_jrc_database, $provider_device_id_jrc_database2, $privacy_text, $privacy_text2, $is_invoicing_enabled, $is_invoicing_enabled2, $provider_url_logo, $provider_url_logo2, $general_terms_text, $general_terms_text2, $background_image_path, $background_image_path2, $logo_path, $logo_path2, $primary_color, $primary_color2, $secondary_color, $secondary_color2, $font_family, $font_family2, $header_font_family, $header_font_family2, $updated_at, $updated_at2, $punchline, $punchline2, $button_color, $button_color2, $show_company_field_for_customers, $show_company_field_for_customers2, $attach_test_result, $attach_test_result2, $list_of_companies_for_company_field_for_customers, $list_of_companies_for_company_field_for_customers2, $list_of_zip_codes_for_customers, $list_of_zip_codes_for_customers2, $enable_availability_locations, $enable_availability_locations2, $mobile_scanning_enabled, $mobile_scanning_enabled2, $force_booking_slot_selection, $force_booking_slot_selection2, $time_slot_duration, $time_slot_duration2, $duration_of_day_pass_validity, $duration_of_day_pass_validity2, $max_bookings_per_slot, $max_bookings_per_slot2, $opening_time, $opening_time2, $closing_time, $closing_time2, $is_copy_availability_from_previous_week, $is_copy_availability_from_previous_week2, $advance_booking_time_in_minutes, $advance_booking_time_in_minutes2, $editable_days, $editable_days2, $my_probatix_enabled, $my_probatix_enabled2, $my_probatix_client_id, $my_probatix_client_id2, $my_probatix_client_secret, $my_probatix_client_secret2, $internal_code_base, $internal_code_base2, $bsnr, $bsnr2, $tenant_selection_options, $tenant_selection_options2, $send_invoice_automatically, $send_invoice_automatically2, $test_producer, $test_producer2, $provider_street_and_house_number, $provider_street_and_house_number2, $provider_city, $provider_city2, $provider_zip_code, $provider_zip_code2, $provider_location_street_and_house_number, $provider_location_street_and_house_number2, $provider_location_city, $provider_location_city2, $provider_location_zip_code, $provider_location_zip_code2, $onboarding_step, $onboarding_step2, $printer_type, $printer_type2, $show_test_paid_confirmation, $show_test_paid_confirmation2, $status, $status2, $show_available_slots, $show_available_slots2, $address_components, $address_components2, $prefix, $prefix2, $send_full_data_in_report_api, $send_full_data_in_report_api2, $is_availability_set_up, $is_availability_set_up2, $is_instance_cleared, $is_instance_cleared2, $available_product_types, $available_product_types2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaltenantsGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Tenant resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $probatix_customer_id  (optional)
     * @param  string[] $probatix_customer_id2  (optional)
     * @param  string $reporting_api_key  (optional)
     * @param  string[] $reporting_api_key2  (optional)
     * @param  string $base_url  (optional)
     * @param  string[] $base_url2  (optional)
     * @param  string $provider_key  (optional)
     * @param  string[] $provider_key2  (optional)
     * @param  string $deployment_stage  (optional)
     * @param  string[] $deployment_stage2  (optional)
     * @param  string $url_imprint  (optional)
     * @param  string[] $url_imprint2  (optional)
     * @param  string $url_homepage  (optional)
     * @param  string[] $url_homepage2  (optional)
     * @param  string $url_privacy  (optional)
     * @param  string[] $url_privacy2  (optional)
     * @param  string $provider_name  (optional)
     * @param  string[] $provider_name2  (optional)
     * @param  string $provider_address  (optional)
     * @param  string[] $provider_address2  (optional)
     * @param  string $provider_responsible_contact_name  (optional)
     * @param  string[] $provider_responsible_contact_name2  (optional)
     * @param  string $provider_data_privacy_contact  (optional)
     * @param  string[] $provider_data_privacy_contact2  (optional)
     * @param  string $provider_data_privacy_additional_information  (optional)
     * @param  string[] $provider_data_privacy_additional_information2  (optional)
     * @param  string $email_sender_address  (optional)
     * @param  string[] $email_sender_address2  (optional)
     * @param  string $provider_location_name  (optional)
     * @param  string[] $provider_location_name2  (optional)
     * @param  string $provider_location_registration_id  (optional)
     * @param  string[] $provider_location_registration_id2  (optional)
     * @param  string $provider_location_address  (optional)
     * @param  string[] $provider_location_address2  (optional)
     * @param  string $provider_location_phone  (optional)
     * @param  string[] $provider_location_phone2  (optional)
     * @param  string $provider_location_email  (optional)
     * @param  string[] $provider_location_email2  (optional)
     * @param  bool $is_booking_without_payment_allowed  (optional)
     * @param  bool[] $is_booking_without_payment_allowed2  (optional)
     * @param  bool $is_stripe_enabled  (optional)
     * @param  bool[] $is_stripe_enabled2  (optional)
     * @param  string $stripe_payment_methods  (optional)
     * @param  string[] $stripe_payment_methods2  (optional)
     * @param  string $stripe_account_id  (optional)
     * @param  string[] $stripe_account_id2  (optional)
     * @param  string $paypal_environment  (optional)
     * @param  string[] $paypal_environment2  (optional)
     * @param  bool $is_paypal_enabled  (optional)
     * @param  bool[] $is_paypal_enabled2  (optional)
     * @param  string $paypal_client_id  (optional)
     * @param  string[] $paypal_client_id2  (optional)
     * @param  string $paypal_client_secret  (optional)
     * @param  string[] $paypal_client_secret2  (optional)
     * @param  string $provider_test_details  (optional)
     * @param  string[] $provider_test_details2  (optional)
     * @param  int $provider_device_id_jrc_database  (optional)
     * @param  int[] $provider_device_id_jrc_database2  (optional)
     * @param  string $privacy_text  (optional)
     * @param  string[] $privacy_text2  (optional)
     * @param  bool $is_invoicing_enabled  (optional)
     * @param  bool[] $is_invoicing_enabled2  (optional)
     * @param  string $provider_url_logo  (optional)
     * @param  string[] $provider_url_logo2  (optional)
     * @param  string $general_terms_text  (optional)
     * @param  string[] $general_terms_text2  (optional)
     * @param  string $background_image_path  (optional)
     * @param  string[] $background_image_path2  (optional)
     * @param  string $logo_path  (optional)
     * @param  string[] $logo_path2  (optional)
     * @param  string $primary_color  (optional)
     * @param  string[] $primary_color2  (optional)
     * @param  string $secondary_color  (optional)
     * @param  string[] $secondary_color2  (optional)
     * @param  string $font_family  (optional)
     * @param  string[] $font_family2  (optional)
     * @param  string $header_font_family  (optional)
     * @param  string[] $header_font_family2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $punchline  (optional)
     * @param  string[] $punchline2  (optional)
     * @param  string $button_color  (optional)
     * @param  string[] $button_color2  (optional)
     * @param  bool $show_company_field_for_customers  (optional)
     * @param  bool[] $show_company_field_for_customers2  (optional)
     * @param  bool $attach_test_result  (optional)
     * @param  bool[] $attach_test_result2  (optional)
     * @param  string $list_of_companies_for_company_field_for_customers  (optional)
     * @param  string[] $list_of_companies_for_company_field_for_customers2  (optional)
     * @param  string $list_of_zip_codes_for_customers  (optional)
     * @param  string[] $list_of_zip_codes_for_customers2  (optional)
     * @param  bool $enable_availability_locations  (optional)
     * @param  bool[] $enable_availability_locations2  (optional)
     * @param  bool $mobile_scanning_enabled  (optional)
     * @param  bool[] $mobile_scanning_enabled2  (optional)
     * @param  bool $force_booking_slot_selection  (optional)
     * @param  bool[] $force_booking_slot_selection2  (optional)
     * @param  int $time_slot_duration  (optional)
     * @param  int[] $time_slot_duration2  (optional)
     * @param  int $duration_of_day_pass_validity  (optional)
     * @param  int[] $duration_of_day_pass_validity2  (optional)
     * @param  int $max_bookings_per_slot  (optional)
     * @param  int[] $max_bookings_per_slot2  (optional)
     * @param  int $opening_time  (optional)
     * @param  int[] $opening_time2  (optional)
     * @param  int $closing_time  (optional)
     * @param  int[] $closing_time2  (optional)
     * @param  bool $is_copy_availability_from_previous_week  (optional)
     * @param  bool[] $is_copy_availability_from_previous_week2  (optional)
     * @param  int $advance_booking_time_in_minutes  (optional)
     * @param  int[] $advance_booking_time_in_minutes2  (optional)
     * @param  int $editable_days  (optional)
     * @param  int[] $editable_days2  (optional)
     * @param  bool $my_probatix_enabled  (optional)
     * @param  bool[] $my_probatix_enabled2  (optional)
     * @param  string $my_probatix_client_id  (optional)
     * @param  string[] $my_probatix_client_id2  (optional)
     * @param  string $my_probatix_client_secret  (optional)
     * @param  string[] $my_probatix_client_secret2  (optional)
     * @param  int $internal_code_base  (optional)
     * @param  int[] $internal_code_base2  (optional)
     * @param  string $bsnr  (optional)
     * @param  string[] $bsnr2  (optional)
     * @param  string $tenant_selection_options  (optional)
     * @param  string[] $tenant_selection_options2  (optional)
     * @param  bool $send_invoice_automatically  (optional)
     * @param  bool[] $send_invoice_automatically2  (optional)
     * @param  string $test_producer  (optional)
     * @param  string[] $test_producer2  (optional)
     * @param  string $provider_street_and_house_number  (optional)
     * @param  string[] $provider_street_and_house_number2  (optional)
     * @param  string $provider_city  (optional)
     * @param  string[] $provider_city2  (optional)
     * @param  string $provider_zip_code  (optional)
     * @param  string[] $provider_zip_code2  (optional)
     * @param  string $provider_location_street_and_house_number  (optional)
     * @param  string[] $provider_location_street_and_house_number2  (optional)
     * @param  string $provider_location_city  (optional)
     * @param  string[] $provider_location_city2  (optional)
     * @param  string $provider_location_zip_code  (optional)
     * @param  string[] $provider_location_zip_code2  (optional)
     * @param  string $onboarding_step  (optional)
     * @param  string[] $onboarding_step2  (optional)
     * @param  string $printer_type  (optional)
     * @param  string[] $printer_type2  (optional)
     * @param  bool $show_test_paid_confirmation  (optional)
     * @param  bool[] $show_test_paid_confirmation2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  bool $show_available_slots  (optional)
     * @param  bool[] $show_available_slots2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $prefix  (optional)
     * @param  string[] $prefix2  (optional)
     * @param  bool $send_full_data_in_report_api  (optional)
     * @param  bool[] $send_full_data_in_report_api2  (optional)
     * @param  bool $is_availability_set_up  (optional)
     * @param  bool[] $is_availability_set_up2  (optional)
     * @param  bool $is_instance_cleared  (optional)
     * @param  bool[] $is_instance_cleared2  (optional)
     * @param  string $available_product_types  (optional)
     * @param  string[] $available_product_types2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsGetCollectionAsyncWithHttpInfo($page = 1, $probatix_customer_id = null, $probatix_customer_id2 = null, $reporting_api_key = null, $reporting_api_key2 = null, $base_url = null, $base_url2 = null, $provider_key = null, $provider_key2 = null, $deployment_stage = null, $deployment_stage2 = null, $url_imprint = null, $url_imprint2 = null, $url_homepage = null, $url_homepage2 = null, $url_privacy = null, $url_privacy2 = null, $provider_name = null, $provider_name2 = null, $provider_address = null, $provider_address2 = null, $provider_responsible_contact_name = null, $provider_responsible_contact_name2 = null, $provider_data_privacy_contact = null, $provider_data_privacy_contact2 = null, $provider_data_privacy_additional_information = null, $provider_data_privacy_additional_information2 = null, $email_sender_address = null, $email_sender_address2 = null, $provider_location_name = null, $provider_location_name2 = null, $provider_location_registration_id = null, $provider_location_registration_id2 = null, $provider_location_address = null, $provider_location_address2 = null, $provider_location_phone = null, $provider_location_phone2 = null, $provider_location_email = null, $provider_location_email2 = null, $is_booking_without_payment_allowed = null, $is_booking_without_payment_allowed2 = null, $is_stripe_enabled = null, $is_stripe_enabled2 = null, $stripe_payment_methods = null, $stripe_payment_methods2 = null, $stripe_account_id = null, $stripe_account_id2 = null, $paypal_environment = null, $paypal_environment2 = null, $is_paypal_enabled = null, $is_paypal_enabled2 = null, $paypal_client_id = null, $paypal_client_id2 = null, $paypal_client_secret = null, $paypal_client_secret2 = null, $provider_test_details = null, $provider_test_details2 = null, $provider_device_id_jrc_database = null, $provider_device_id_jrc_database2 = null, $privacy_text = null, $privacy_text2 = null, $is_invoicing_enabled = null, $is_invoicing_enabled2 = null, $provider_url_logo = null, $provider_url_logo2 = null, $general_terms_text = null, $general_terms_text2 = null, $background_image_path = null, $background_image_path2 = null, $logo_path = null, $logo_path2 = null, $primary_color = null, $primary_color2 = null, $secondary_color = null, $secondary_color2 = null, $font_family = null, $font_family2 = null, $header_font_family = null, $header_font_family2 = null, $updated_at = null, $updated_at2 = null, $punchline = null, $punchline2 = null, $button_color = null, $button_color2 = null, $show_company_field_for_customers = null, $show_company_field_for_customers2 = null, $attach_test_result = null, $attach_test_result2 = null, $list_of_companies_for_company_field_for_customers = null, $list_of_companies_for_company_field_for_customers2 = null, $list_of_zip_codes_for_customers = null, $list_of_zip_codes_for_customers2 = null, $enable_availability_locations = null, $enable_availability_locations2 = null, $mobile_scanning_enabled = null, $mobile_scanning_enabled2 = null, $force_booking_slot_selection = null, $force_booking_slot_selection2 = null, $time_slot_duration = null, $time_slot_duration2 = null, $duration_of_day_pass_validity = null, $duration_of_day_pass_validity2 = null, $max_bookings_per_slot = null, $max_bookings_per_slot2 = null, $opening_time = null, $opening_time2 = null, $closing_time = null, $closing_time2 = null, $is_copy_availability_from_previous_week = null, $is_copy_availability_from_previous_week2 = null, $advance_booking_time_in_minutes = null, $advance_booking_time_in_minutes2 = null, $editable_days = null, $editable_days2 = null, $my_probatix_enabled = null, $my_probatix_enabled2 = null, $my_probatix_client_id = null, $my_probatix_client_id2 = null, $my_probatix_client_secret = null, $my_probatix_client_secret2 = null, $internal_code_base = null, $internal_code_base2 = null, $bsnr = null, $bsnr2 = null, $tenant_selection_options = null, $tenant_selection_options2 = null, $send_invoice_automatically = null, $send_invoice_automatically2 = null, $test_producer = null, $test_producer2 = null, $provider_street_and_house_number = null, $provider_street_and_house_number2 = null, $provider_city = null, $provider_city2 = null, $provider_zip_code = null, $provider_zip_code2 = null, $provider_location_street_and_house_number = null, $provider_location_street_and_house_number2 = null, $provider_location_city = null, $provider_location_city2 = null, $provider_location_zip_code = null, $provider_location_zip_code2 = null, $onboarding_step = null, $onboarding_step2 = null, $printer_type = null, $printer_type2 = null, $show_test_paid_confirmation = null, $show_test_paid_confirmation2 = null, $status = null, $status2 = null, $show_available_slots = null, $show_available_slots2 = null, $address_components = null, $address_components2 = null, $prefix = null, $prefix2 = null, $send_full_data_in_report_api = null, $send_full_data_in_report_api2 = null, $is_availability_set_up = null, $is_availability_set_up2 = null, $is_instance_cleared = null, $is_instance_cleared2 = null, $available_product_types = null, $available_product_types2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaltenantsGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tenant[]';
        $request = $this->apiApiInternaltenantsGetCollectionRequest($page, $probatix_customer_id, $probatix_customer_id2, $reporting_api_key, $reporting_api_key2, $base_url, $base_url2, $provider_key, $provider_key2, $deployment_stage, $deployment_stage2, $url_imprint, $url_imprint2, $url_homepage, $url_homepage2, $url_privacy, $url_privacy2, $provider_name, $provider_name2, $provider_address, $provider_address2, $provider_responsible_contact_name, $provider_responsible_contact_name2, $provider_data_privacy_contact, $provider_data_privacy_contact2, $provider_data_privacy_additional_information, $provider_data_privacy_additional_information2, $email_sender_address, $email_sender_address2, $provider_location_name, $provider_location_name2, $provider_location_registration_id, $provider_location_registration_id2, $provider_location_address, $provider_location_address2, $provider_location_phone, $provider_location_phone2, $provider_location_email, $provider_location_email2, $is_booking_without_payment_allowed, $is_booking_without_payment_allowed2, $is_stripe_enabled, $is_stripe_enabled2, $stripe_payment_methods, $stripe_payment_methods2, $stripe_account_id, $stripe_account_id2, $paypal_environment, $paypal_environment2, $is_paypal_enabled, $is_paypal_enabled2, $paypal_client_id, $paypal_client_id2, $paypal_client_secret, $paypal_client_secret2, $provider_test_details, $provider_test_details2, $provider_device_id_jrc_database, $provider_device_id_jrc_database2, $privacy_text, $privacy_text2, $is_invoicing_enabled, $is_invoicing_enabled2, $provider_url_logo, $provider_url_logo2, $general_terms_text, $general_terms_text2, $background_image_path, $background_image_path2, $logo_path, $logo_path2, $primary_color, $primary_color2, $secondary_color, $secondary_color2, $font_family, $font_family2, $header_font_family, $header_font_family2, $updated_at, $updated_at2, $punchline, $punchline2, $button_color, $button_color2, $show_company_field_for_customers, $show_company_field_for_customers2, $attach_test_result, $attach_test_result2, $list_of_companies_for_company_field_for_customers, $list_of_companies_for_company_field_for_customers2, $list_of_zip_codes_for_customers, $list_of_zip_codes_for_customers2, $enable_availability_locations, $enable_availability_locations2, $mobile_scanning_enabled, $mobile_scanning_enabled2, $force_booking_slot_selection, $force_booking_slot_selection2, $time_slot_duration, $time_slot_duration2, $duration_of_day_pass_validity, $duration_of_day_pass_validity2, $max_bookings_per_slot, $max_bookings_per_slot2, $opening_time, $opening_time2, $closing_time, $closing_time2, $is_copy_availability_from_previous_week, $is_copy_availability_from_previous_week2, $advance_booking_time_in_minutes, $advance_booking_time_in_minutes2, $editable_days, $editable_days2, $my_probatix_enabled, $my_probatix_enabled2, $my_probatix_client_id, $my_probatix_client_id2, $my_probatix_client_secret, $my_probatix_client_secret2, $internal_code_base, $internal_code_base2, $bsnr, $bsnr2, $tenant_selection_options, $tenant_selection_options2, $send_invoice_automatically, $send_invoice_automatically2, $test_producer, $test_producer2, $provider_street_and_house_number, $provider_street_and_house_number2, $provider_city, $provider_city2, $provider_zip_code, $provider_zip_code2, $provider_location_street_and_house_number, $provider_location_street_and_house_number2, $provider_location_city, $provider_location_city2, $provider_location_zip_code, $provider_location_zip_code2, $onboarding_step, $onboarding_step2, $printer_type, $printer_type2, $show_test_paid_confirmation, $show_test_paid_confirmation2, $status, $status2, $show_available_slots, $show_available_slots2, $address_components, $address_components2, $prefix, $prefix2, $send_full_data_in_report_api, $send_full_data_in_report_api2, $is_availability_set_up, $is_availability_set_up2, $is_instance_cleared, $is_instance_cleared2, $available_product_types, $available_product_types2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaltenantsGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $probatix_customer_id  (optional)
     * @param  string[] $probatix_customer_id2  (optional)
     * @param  string $reporting_api_key  (optional)
     * @param  string[] $reporting_api_key2  (optional)
     * @param  string $base_url  (optional)
     * @param  string[] $base_url2  (optional)
     * @param  string $provider_key  (optional)
     * @param  string[] $provider_key2  (optional)
     * @param  string $deployment_stage  (optional)
     * @param  string[] $deployment_stage2  (optional)
     * @param  string $url_imprint  (optional)
     * @param  string[] $url_imprint2  (optional)
     * @param  string $url_homepage  (optional)
     * @param  string[] $url_homepage2  (optional)
     * @param  string $url_privacy  (optional)
     * @param  string[] $url_privacy2  (optional)
     * @param  string $provider_name  (optional)
     * @param  string[] $provider_name2  (optional)
     * @param  string $provider_address  (optional)
     * @param  string[] $provider_address2  (optional)
     * @param  string $provider_responsible_contact_name  (optional)
     * @param  string[] $provider_responsible_contact_name2  (optional)
     * @param  string $provider_data_privacy_contact  (optional)
     * @param  string[] $provider_data_privacy_contact2  (optional)
     * @param  string $provider_data_privacy_additional_information  (optional)
     * @param  string[] $provider_data_privacy_additional_information2  (optional)
     * @param  string $email_sender_address  (optional)
     * @param  string[] $email_sender_address2  (optional)
     * @param  string $provider_location_name  (optional)
     * @param  string[] $provider_location_name2  (optional)
     * @param  string $provider_location_registration_id  (optional)
     * @param  string[] $provider_location_registration_id2  (optional)
     * @param  string $provider_location_address  (optional)
     * @param  string[] $provider_location_address2  (optional)
     * @param  string $provider_location_phone  (optional)
     * @param  string[] $provider_location_phone2  (optional)
     * @param  string $provider_location_email  (optional)
     * @param  string[] $provider_location_email2  (optional)
     * @param  bool $is_booking_without_payment_allowed  (optional)
     * @param  bool[] $is_booking_without_payment_allowed2  (optional)
     * @param  bool $is_stripe_enabled  (optional)
     * @param  bool[] $is_stripe_enabled2  (optional)
     * @param  string $stripe_payment_methods  (optional)
     * @param  string[] $stripe_payment_methods2  (optional)
     * @param  string $stripe_account_id  (optional)
     * @param  string[] $stripe_account_id2  (optional)
     * @param  string $paypal_environment  (optional)
     * @param  string[] $paypal_environment2  (optional)
     * @param  bool $is_paypal_enabled  (optional)
     * @param  bool[] $is_paypal_enabled2  (optional)
     * @param  string $paypal_client_id  (optional)
     * @param  string[] $paypal_client_id2  (optional)
     * @param  string $paypal_client_secret  (optional)
     * @param  string[] $paypal_client_secret2  (optional)
     * @param  string $provider_test_details  (optional)
     * @param  string[] $provider_test_details2  (optional)
     * @param  int $provider_device_id_jrc_database  (optional)
     * @param  int[] $provider_device_id_jrc_database2  (optional)
     * @param  string $privacy_text  (optional)
     * @param  string[] $privacy_text2  (optional)
     * @param  bool $is_invoicing_enabled  (optional)
     * @param  bool[] $is_invoicing_enabled2  (optional)
     * @param  string $provider_url_logo  (optional)
     * @param  string[] $provider_url_logo2  (optional)
     * @param  string $general_terms_text  (optional)
     * @param  string[] $general_terms_text2  (optional)
     * @param  string $background_image_path  (optional)
     * @param  string[] $background_image_path2  (optional)
     * @param  string $logo_path  (optional)
     * @param  string[] $logo_path2  (optional)
     * @param  string $primary_color  (optional)
     * @param  string[] $primary_color2  (optional)
     * @param  string $secondary_color  (optional)
     * @param  string[] $secondary_color2  (optional)
     * @param  string $font_family  (optional)
     * @param  string[] $font_family2  (optional)
     * @param  string $header_font_family  (optional)
     * @param  string[] $header_font_family2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $punchline  (optional)
     * @param  string[] $punchline2  (optional)
     * @param  string $button_color  (optional)
     * @param  string[] $button_color2  (optional)
     * @param  bool $show_company_field_for_customers  (optional)
     * @param  bool[] $show_company_field_for_customers2  (optional)
     * @param  bool $attach_test_result  (optional)
     * @param  bool[] $attach_test_result2  (optional)
     * @param  string $list_of_companies_for_company_field_for_customers  (optional)
     * @param  string[] $list_of_companies_for_company_field_for_customers2  (optional)
     * @param  string $list_of_zip_codes_for_customers  (optional)
     * @param  string[] $list_of_zip_codes_for_customers2  (optional)
     * @param  bool $enable_availability_locations  (optional)
     * @param  bool[] $enable_availability_locations2  (optional)
     * @param  bool $mobile_scanning_enabled  (optional)
     * @param  bool[] $mobile_scanning_enabled2  (optional)
     * @param  bool $force_booking_slot_selection  (optional)
     * @param  bool[] $force_booking_slot_selection2  (optional)
     * @param  int $time_slot_duration  (optional)
     * @param  int[] $time_slot_duration2  (optional)
     * @param  int $duration_of_day_pass_validity  (optional)
     * @param  int[] $duration_of_day_pass_validity2  (optional)
     * @param  int $max_bookings_per_slot  (optional)
     * @param  int[] $max_bookings_per_slot2  (optional)
     * @param  int $opening_time  (optional)
     * @param  int[] $opening_time2  (optional)
     * @param  int $closing_time  (optional)
     * @param  int[] $closing_time2  (optional)
     * @param  bool $is_copy_availability_from_previous_week  (optional)
     * @param  bool[] $is_copy_availability_from_previous_week2  (optional)
     * @param  int $advance_booking_time_in_minutes  (optional)
     * @param  int[] $advance_booking_time_in_minutes2  (optional)
     * @param  int $editable_days  (optional)
     * @param  int[] $editable_days2  (optional)
     * @param  bool $my_probatix_enabled  (optional)
     * @param  bool[] $my_probatix_enabled2  (optional)
     * @param  string $my_probatix_client_id  (optional)
     * @param  string[] $my_probatix_client_id2  (optional)
     * @param  string $my_probatix_client_secret  (optional)
     * @param  string[] $my_probatix_client_secret2  (optional)
     * @param  int $internal_code_base  (optional)
     * @param  int[] $internal_code_base2  (optional)
     * @param  string $bsnr  (optional)
     * @param  string[] $bsnr2  (optional)
     * @param  string $tenant_selection_options  (optional)
     * @param  string[] $tenant_selection_options2  (optional)
     * @param  bool $send_invoice_automatically  (optional)
     * @param  bool[] $send_invoice_automatically2  (optional)
     * @param  string $test_producer  (optional)
     * @param  string[] $test_producer2  (optional)
     * @param  string $provider_street_and_house_number  (optional)
     * @param  string[] $provider_street_and_house_number2  (optional)
     * @param  string $provider_city  (optional)
     * @param  string[] $provider_city2  (optional)
     * @param  string $provider_zip_code  (optional)
     * @param  string[] $provider_zip_code2  (optional)
     * @param  string $provider_location_street_and_house_number  (optional)
     * @param  string[] $provider_location_street_and_house_number2  (optional)
     * @param  string $provider_location_city  (optional)
     * @param  string[] $provider_location_city2  (optional)
     * @param  string $provider_location_zip_code  (optional)
     * @param  string[] $provider_location_zip_code2  (optional)
     * @param  string $onboarding_step  (optional)
     * @param  string[] $onboarding_step2  (optional)
     * @param  string $printer_type  (optional)
     * @param  string[] $printer_type2  (optional)
     * @param  bool $show_test_paid_confirmation  (optional)
     * @param  bool[] $show_test_paid_confirmation2  (optional)
     * @param  string $status  (optional)
     * @param  string[] $status2  (optional)
     * @param  bool $show_available_slots  (optional)
     * @param  bool[] $show_available_slots2  (optional)
     * @param  string $address_components  (optional)
     * @param  string[] $address_components2  (optional)
     * @param  string $prefix  (optional)
     * @param  string[] $prefix2  (optional)
     * @param  bool $send_full_data_in_report_api  (optional)
     * @param  bool[] $send_full_data_in_report_api2  (optional)
     * @param  bool $is_availability_set_up  (optional)
     * @param  bool[] $is_availability_set_up2  (optional)
     * @param  bool $is_instance_cleared  (optional)
     * @param  bool[] $is_instance_cleared2  (optional)
     * @param  string $available_product_types  (optional)
     * @param  string[] $available_product_types2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaltenantsGetCollectionRequest($page = 1, $probatix_customer_id = null, $probatix_customer_id2 = null, $reporting_api_key = null, $reporting_api_key2 = null, $base_url = null, $base_url2 = null, $provider_key = null, $provider_key2 = null, $deployment_stage = null, $deployment_stage2 = null, $url_imprint = null, $url_imprint2 = null, $url_homepage = null, $url_homepage2 = null, $url_privacy = null, $url_privacy2 = null, $provider_name = null, $provider_name2 = null, $provider_address = null, $provider_address2 = null, $provider_responsible_contact_name = null, $provider_responsible_contact_name2 = null, $provider_data_privacy_contact = null, $provider_data_privacy_contact2 = null, $provider_data_privacy_additional_information = null, $provider_data_privacy_additional_information2 = null, $email_sender_address = null, $email_sender_address2 = null, $provider_location_name = null, $provider_location_name2 = null, $provider_location_registration_id = null, $provider_location_registration_id2 = null, $provider_location_address = null, $provider_location_address2 = null, $provider_location_phone = null, $provider_location_phone2 = null, $provider_location_email = null, $provider_location_email2 = null, $is_booking_without_payment_allowed = null, $is_booking_without_payment_allowed2 = null, $is_stripe_enabled = null, $is_stripe_enabled2 = null, $stripe_payment_methods = null, $stripe_payment_methods2 = null, $stripe_account_id = null, $stripe_account_id2 = null, $paypal_environment = null, $paypal_environment2 = null, $is_paypal_enabled = null, $is_paypal_enabled2 = null, $paypal_client_id = null, $paypal_client_id2 = null, $paypal_client_secret = null, $paypal_client_secret2 = null, $provider_test_details = null, $provider_test_details2 = null, $provider_device_id_jrc_database = null, $provider_device_id_jrc_database2 = null, $privacy_text = null, $privacy_text2 = null, $is_invoicing_enabled = null, $is_invoicing_enabled2 = null, $provider_url_logo = null, $provider_url_logo2 = null, $general_terms_text = null, $general_terms_text2 = null, $background_image_path = null, $background_image_path2 = null, $logo_path = null, $logo_path2 = null, $primary_color = null, $primary_color2 = null, $secondary_color = null, $secondary_color2 = null, $font_family = null, $font_family2 = null, $header_font_family = null, $header_font_family2 = null, $updated_at = null, $updated_at2 = null, $punchline = null, $punchline2 = null, $button_color = null, $button_color2 = null, $show_company_field_for_customers = null, $show_company_field_for_customers2 = null, $attach_test_result = null, $attach_test_result2 = null, $list_of_companies_for_company_field_for_customers = null, $list_of_companies_for_company_field_for_customers2 = null, $list_of_zip_codes_for_customers = null, $list_of_zip_codes_for_customers2 = null, $enable_availability_locations = null, $enable_availability_locations2 = null, $mobile_scanning_enabled = null, $mobile_scanning_enabled2 = null, $force_booking_slot_selection = null, $force_booking_slot_selection2 = null, $time_slot_duration = null, $time_slot_duration2 = null, $duration_of_day_pass_validity = null, $duration_of_day_pass_validity2 = null, $max_bookings_per_slot = null, $max_bookings_per_slot2 = null, $opening_time = null, $opening_time2 = null, $closing_time = null, $closing_time2 = null, $is_copy_availability_from_previous_week = null, $is_copy_availability_from_previous_week2 = null, $advance_booking_time_in_minutes = null, $advance_booking_time_in_minutes2 = null, $editable_days = null, $editable_days2 = null, $my_probatix_enabled = null, $my_probatix_enabled2 = null, $my_probatix_client_id = null, $my_probatix_client_id2 = null, $my_probatix_client_secret = null, $my_probatix_client_secret2 = null, $internal_code_base = null, $internal_code_base2 = null, $bsnr = null, $bsnr2 = null, $tenant_selection_options = null, $tenant_selection_options2 = null, $send_invoice_automatically = null, $send_invoice_automatically2 = null, $test_producer = null, $test_producer2 = null, $provider_street_and_house_number = null, $provider_street_and_house_number2 = null, $provider_city = null, $provider_city2 = null, $provider_zip_code = null, $provider_zip_code2 = null, $provider_location_street_and_house_number = null, $provider_location_street_and_house_number2 = null, $provider_location_city = null, $provider_location_city2 = null, $provider_location_zip_code = null, $provider_location_zip_code2 = null, $onboarding_step = null, $onboarding_step2 = null, $printer_type = null, $printer_type2 = null, $show_test_paid_confirmation = null, $show_test_paid_confirmation2 = null, $status = null, $status2 = null, $show_available_slots = null, $show_available_slots2 = null, $address_components = null, $address_components2 = null, $prefix = null, $prefix2 = null, $send_full_data_in_report_api = null, $send_full_data_in_report_api2 = null, $is_availability_set_up = null, $is_availability_set_up2 = null, $is_instance_cleared = null, $is_instance_cleared2 = null, $available_product_types = null, $available_product_types2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternaltenantsGetCollection'][0])
    {









































































































































































        $resourcePath = '/api-internal/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $probatix_customer_id,
            'probatixCustomerId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $probatix_customer_id2,
            'probatixCustomerId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reporting_api_key,
            'reportingApiKey', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $reporting_api_key2,
            'reportingApiKey[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $base_url,
            'baseUrl', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $base_url2,
            'baseUrl[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_key,
            'providerKey', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_key2,
            'providerKey[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deployment_stage,
            'deploymentStage', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deployment_stage2,
            'deploymentStage[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_imprint,
            'urlImprint', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_imprint2,
            'urlImprint[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_homepage,
            'urlHomepage', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_homepage2,
            'urlHomepage[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_privacy,
            'urlPrivacy', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $url_privacy2,
            'urlPrivacy[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_name,
            'providerName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_name2,
            'providerName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_address,
            'providerAddress', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_address2,
            'providerAddress[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_responsible_contact_name,
            'providerResponsibleContactName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_responsible_contact_name2,
            'providerResponsibleContactName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_data_privacy_contact,
            'providerDataPrivacyContact', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_data_privacy_contact2,
            'providerDataPrivacyContact[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_data_privacy_additional_information,
            'providerDataPrivacyAdditionalInformation', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_data_privacy_additional_information2,
            'providerDataPrivacyAdditionalInformation[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_sender_address,
            'emailSenderAddress', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email_sender_address2,
            'emailSenderAddress[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_name,
            'providerLocationName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_name2,
            'providerLocationName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_registration_id,
            'providerLocationRegistrationId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_registration_id2,
            'providerLocationRegistrationId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_address,
            'providerLocationAddress', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_address2,
            'providerLocationAddress[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_phone,
            'providerLocationPhone', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_phone2,
            'providerLocationPhone[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_email,
            'providerLocationEmail', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_email2,
            'providerLocationEmail[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_booking_without_payment_allowed,
            'isBookingWithoutPaymentAllowed', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_booking_without_payment_allowed2,
            'isBookingWithoutPaymentAllowed[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_stripe_enabled,
            'isStripeEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_stripe_enabled2,
            'isStripeEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stripe_payment_methods,
            'stripePaymentMethods', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stripe_payment_methods2,
            'stripePaymentMethods[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stripe_account_id,
            'stripeAccountId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $stripe_account_id2,
            'stripeAccountId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_environment,
            'paypalEnvironment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_environment2,
            'paypalEnvironment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_paypal_enabled,
            'isPaypalEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_paypal_enabled2,
            'isPaypalEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_client_id,
            'paypalClientId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_client_id2,
            'paypalClientId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_client_secret,
            'paypalClientSecret', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $paypal_client_secret2,
            'paypalClientSecret[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_test_details,
            'providerTestDetails', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_test_details2,
            'providerTestDetails[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_device_id_jrc_database,
            'providerDeviceIdJrcDatabase', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_device_id_jrc_database2,
            'providerDeviceIdJrcDatabase[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $privacy_text,
            'privacyText', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $privacy_text2,
            'privacyText[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_invoicing_enabled,
            'isInvoicingEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_invoicing_enabled2,
            'isInvoicingEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_url_logo,
            'providerUrlLogo', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_url_logo2,
            'providerUrlLogo[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $general_terms_text,
            'generalTermsText', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $general_terms_text2,
            'generalTermsText[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_image_path,
            'backgroundImagePath', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $background_image_path2,
            'backgroundImagePath[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $logo_path,
            'logoPath', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $logo_path2,
            'logoPath[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $primary_color,
            'primaryColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $primary_color2,
            'primaryColor[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secondary_color,
            'secondaryColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $secondary_color2,
            'secondaryColor[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $font_family,
            'fontFamily', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $font_family2,
            'fontFamily[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $header_font_family,
            'headerFontFamily', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $header_font_family2,
            'headerFontFamily[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $punchline,
            'punchline', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $punchline2,
            'punchline[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $button_color,
            'buttonColor', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $button_color2,
            'buttonColor[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_company_field_for_customers,
            'showCompanyFieldForCustomers', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_company_field_for_customers2,
            'showCompanyFieldForCustomers[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attach_test_result,
            'attachTestResult', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $attach_test_result2,
            'attachTestResult[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_of_companies_for_company_field_for_customers,
            'listOfCompaniesForCompanyFieldForCustomers', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_of_companies_for_company_field_for_customers2,
            'listOfCompaniesForCompanyFieldForCustomers[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_of_zip_codes_for_customers,
            'listOfZipCodesForCustomers', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $list_of_zip_codes_for_customers2,
            'listOfZipCodesForCustomers[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_availability_locations,
            'enableAvailabilityLocations', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $enable_availability_locations2,
            'enableAvailabilityLocations[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mobile_scanning_enabled,
            'mobileScanningEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mobile_scanning_enabled2,
            'mobileScanningEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_booking_slot_selection,
            'forceBookingSlotSelection', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $force_booking_slot_selection2,
            'forceBookingSlotSelection[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_slot_duration,
            'timeSlotDuration', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $time_slot_duration2,
            'timeSlotDuration[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration_of_day_pass_validity,
            'durationOfDayPassValidity', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $duration_of_day_pass_validity2,
            'durationOfDayPassValidity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_bookings_per_slot,
            'maxBookingsPerSlot', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $max_bookings_per_slot2,
            'maxBookingsPerSlot[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $opening_time,
            'openingTime', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $opening_time2,
            'openingTime[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $closing_time,
            'closingTime', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $closing_time2,
            'closingTime[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_copy_availability_from_previous_week,
            'isCopyAvailabilityFromPreviousWeek', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_copy_availability_from_previous_week2,
            'isCopyAvailabilityFromPreviousWeek[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $advance_booking_time_in_minutes,
            'advanceBookingTimeInMinutes', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $advance_booking_time_in_minutes2,
            'advanceBookingTimeInMinutes[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $editable_days,
            'editableDays', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $editable_days2,
            'editableDays[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_enabled,
            'myProbatixEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_enabled2,
            'myProbatixEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_client_id,
            'myProbatixClientId', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_client_id2,
            'myProbatixClientId[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_client_secret,
            'myProbatixClientSecret', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $my_probatix_client_secret2,
            'myProbatixClientSecret[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code_base,
            'internalCodeBase', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $internal_code_base2,
            'internalCodeBase[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bsnr,
            'bsnr', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $bsnr2,
            'bsnr[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_selection_options,
            'tenantSelectionOptions', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $tenant_selection_options2,
            'tenantSelectionOptions[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_invoice_automatically,
            'sendInvoiceAutomatically', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_invoice_automatically2,
            'sendInvoiceAutomatically[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_producer,
            'testProducer', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $test_producer2,
            'testProducer[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_street_and_house_number,
            'providerStreetAndHouseNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_street_and_house_number2,
            'providerStreetAndHouseNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_city,
            'providerCity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_city2,
            'providerCity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_zip_code,
            'providerZipCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_zip_code2,
            'providerZipCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_street_and_house_number,
            'providerLocationStreetAndHouseNumber', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_street_and_house_number2,
            'providerLocationStreetAndHouseNumber[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_city,
            'providerLocationCity', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_city2,
            'providerLocationCity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_zip_code,
            'providerLocationZipCode', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $provider_location_zip_code2,
            'providerLocationZipCode[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onboarding_step,
            'onboardingStep', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $onboarding_step2,
            'onboardingStep[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $printer_type,
            'printerType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $printer_type2,
            'printerType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_test_paid_confirmation,
            'showTestPaidConfirmation', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_test_paid_confirmation2,
            'showTestPaidConfirmation[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status2,
            'status[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_available_slots,
            'showAvailableSlots', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $show_available_slots2,
            'showAvailableSlots[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_components,
            'addressComponents', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $address_components2,
            'addressComponents[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefix,
            'prefix', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $prefix2,
            'prefix[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_full_data_in_report_api,
            'sendFullDataInReportApi', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_full_data_in_report_api2,
            'sendFullDataInReportApi[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_availability_set_up,
            'isAvailabilitySetUp', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_availability_set_up2,
            'isAvailabilitySetUp[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_instance_cleared,
            'isInstanceCleared', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $is_instance_cleared2,
            'isInstanceCleared[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_product_types,
            'availableProductTypes', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $available_product_types2,
            'availableProductTypes[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaltenantsPost
     *
     * Creates a Tenant resource.
     *
     * @param  \OpenAPI\Client\Model\Tenant $tenant The new Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tenant
     */
    public function apiApiInternaltenantsPost($tenant, string $contentType = self::contentTypes['apiApiInternaltenantsPost'][0])
    {
        list($response) = $this->apiApiInternaltenantsPostWithHttpInfo($tenant, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaltenantsPostWithHttpInfo
     *
     * Creates a Tenant resource.
     *
     * @param  \OpenAPI\Client\Model\Tenant $tenant The new Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaltenantsPostWithHttpInfo($tenant, string $contentType = self::contentTypes['apiApiInternaltenantsPost'][0])
    {
        $request = $this->apiApiInternaltenantsPostRequest($tenant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Tenant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tenant' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tenant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tenant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaltenantsPostAsync
     *
     * Creates a Tenant resource.
     *
     * @param  \OpenAPI\Client\Model\Tenant $tenant The new Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsPostAsync($tenant, string $contentType = self::contentTypes['apiApiInternaltenantsPost'][0])
    {
        return $this->apiApiInternaltenantsPostAsyncWithHttpInfo($tenant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaltenantsPostAsyncWithHttpInfo
     *
     * Creates a Tenant resource.
     *
     * @param  \OpenAPI\Client\Model\Tenant $tenant The new Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsPostAsyncWithHttpInfo($tenant, string $contentType = self::contentTypes['apiApiInternaltenantsPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tenant';
        $request = $this->apiApiInternaltenantsPostRequest($tenant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaltenantsPost'
     *
     * @param  \OpenAPI\Client\Model\Tenant $tenant The new Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaltenantsPostRequest($tenant, string $contentType = self::contentTypes['apiApiInternaltenantsPost'][0])
    {

        // verify the required parameter 'tenant' is set
        if ($tenant === null || (is_array($tenant) && count($tenant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant when calling apiApiInternaltenantsPost'
            );
        }


        $resourcePath = '/api-internal/tenants';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tenant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tenant));
            } else {
                $httpBody = $tenant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaltenantsUuidGet
     *
     * Retrieves a Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tenant
     */
    public function apiApiInternaltenantsUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternaltenantsUuidGet'][0])
    {
        list($response) = $this->apiApiInternaltenantsUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaltenantsUuidGetWithHttpInfo
     *
     * Retrieves a Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaltenantsUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternaltenantsUuidGet'][0])
    {
        $request = $this->apiApiInternaltenantsUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tenant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tenant' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tenant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tenant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaltenantsUuidGetAsync
     *
     * Retrieves a Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternaltenantsUuidGet'][0])
    {
        return $this->apiApiInternaltenantsUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaltenantsUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternaltenantsUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tenant';
        $request = $this->apiApiInternaltenantsUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaltenantsUuidGet'
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaltenantsUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternaltenantsUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternaltenantsUuidGet'
            );
        }


        $resourcePath = '/api-internal/tenants/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternaltenantsUuidPatch
     *
     * Updates the Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  \OpenAPI\Client\Model\Tenant $tenant The updated Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Tenant
     */
    public function apiApiInternaltenantsUuidPatch($uuid, $tenant, string $contentType = self::contentTypes['apiApiInternaltenantsUuidPatch'][0])
    {
        list($response) = $this->apiApiInternaltenantsUuidPatchWithHttpInfo($uuid, $tenant, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternaltenantsUuidPatchWithHttpInfo
     *
     * Updates the Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  \OpenAPI\Client\Model\Tenant $tenant The updated Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Tenant, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternaltenantsUuidPatchWithHttpInfo($uuid, $tenant, string $contentType = self::contentTypes['apiApiInternaltenantsUuidPatch'][0])
    {
        $request = $this->apiApiInternaltenantsUuidPatchRequest($uuid, $tenant, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Tenant' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Tenant' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Tenant', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Tenant';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Tenant',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternaltenantsUuidPatchAsync
     *
     * Updates the Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  \OpenAPI\Client\Model\Tenant $tenant The updated Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsUuidPatchAsync($uuid, $tenant, string $contentType = self::contentTypes['apiApiInternaltenantsUuidPatch'][0])
    {
        return $this->apiApiInternaltenantsUuidPatchAsyncWithHttpInfo($uuid, $tenant, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternaltenantsUuidPatchAsyncWithHttpInfo
     *
     * Updates the Tenant resource.
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  \OpenAPI\Client\Model\Tenant $tenant The updated Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternaltenantsUuidPatchAsyncWithHttpInfo($uuid, $tenant, string $contentType = self::contentTypes['apiApiInternaltenantsUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Tenant';
        $request = $this->apiApiInternaltenantsUuidPatchRequest($uuid, $tenant, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternaltenantsUuidPatch'
     *
     * @param  string $uuid Tenant identifier (required)
     * @param  \OpenAPI\Client\Model\Tenant $tenant The updated Tenant resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternaltenantsUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternaltenantsUuidPatchRequest($uuid, $tenant, string $contentType = self::contentTypes['apiApiInternaltenantsUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternaltenantsUuidPatch'
            );
        }

        // verify the required parameter 'tenant' is set
        if ($tenant === null || (is_array($tenant) && count($tenant) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $tenant when calling apiApiInternaltenantsUuidPatch'
            );
        }


        $resourcePath = '/api-internal/tenants/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($tenant)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($tenant));
            } else {
                $httpBody = $tenant;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalusersGetCollection
     *
     * Retrieves the collection of User resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $roles  (optional)
     * @param  string[] $roles2  (optional)
     * @param  string $password  (optional)
     * @param  string[] $password2  (optional)
     * @param  string $username  (optional)
     * @param  string[] $username2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  bool $mfa_enabled  (optional)
     * @param  bool[] $mfa_enabled2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  bool $deleted  (optional)
     * @param  bool[] $deleted2  (optional)
     * @param  string $login_token  (optional)
     * @param  string[] $login_token2  (optional)
     * @param  bool $send_new_appointment_email  (optional)
     * @param  bool[] $send_new_appointment_email2  (optional)
     * @param  bool $send_test_evaluated_email  (optional)
     * @param  bool[] $send_test_evaluated_email2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User[]
     */
    public function apiApiInternalusersGetCollection($page = 1, $roles = null, $roles2 = null, $password = null, $password2 = null, $username = null, $username2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $mfa_enabled = null, $mfa_enabled2 = null, $active = null, $active2 = null, $deleted = null, $deleted2 = null, $login_token = null, $login_token2 = null, $send_new_appointment_email = null, $send_new_appointment_email2 = null, $send_test_evaluated_email = null, $send_test_evaluated_email2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalusersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalusersGetCollectionWithHttpInfo($page, $roles, $roles2, $password, $password2, $username, $username2, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $mfa_enabled, $mfa_enabled2, $active, $active2, $deleted, $deleted2, $login_token, $login_token2, $send_new_appointment_email, $send_new_appointment_email2, $send_test_evaluated_email, $send_test_evaluated_email2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalusersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of User resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $roles  (optional)
     * @param  string[] $roles2  (optional)
     * @param  string $password  (optional)
     * @param  string[] $password2  (optional)
     * @param  string $username  (optional)
     * @param  string[] $username2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  bool $mfa_enabled  (optional)
     * @param  bool[] $mfa_enabled2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  bool $deleted  (optional)
     * @param  bool[] $deleted2  (optional)
     * @param  string $login_token  (optional)
     * @param  string[] $login_token2  (optional)
     * @param  bool $send_new_appointment_email  (optional)
     * @param  bool[] $send_new_appointment_email2  (optional)
     * @param  bool $send_test_evaluated_email  (optional)
     * @param  bool[] $send_test_evaluated_email2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalusersGetCollectionWithHttpInfo($page = 1, $roles = null, $roles2 = null, $password = null, $password2 = null, $username = null, $username2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $mfa_enabled = null, $mfa_enabled2 = null, $active = null, $active2 = null, $deleted = null, $deleted2 = null, $login_token = null, $login_token2 = null, $send_new_appointment_email = null, $send_new_appointment_email2 = null, $send_test_evaluated_email = null, $send_test_evaluated_email2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalusersGetCollection'][0])
    {
        $request = $this->apiApiInternalusersGetCollectionRequest($page, $roles, $roles2, $password, $password2, $username, $username2, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $mfa_enabled, $mfa_enabled2, $active, $active2, $deleted, $deleted2, $login_token, $login_token2, $send_new_appointment_email, $send_new_appointment_email2, $send_test_evaluated_email, $send_test_evaluated_email2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalusersGetCollectionAsync
     *
     * Retrieves the collection of User resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $roles  (optional)
     * @param  string[] $roles2  (optional)
     * @param  string $password  (optional)
     * @param  string[] $password2  (optional)
     * @param  string $username  (optional)
     * @param  string[] $username2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  bool $mfa_enabled  (optional)
     * @param  bool[] $mfa_enabled2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  bool $deleted  (optional)
     * @param  bool[] $deleted2  (optional)
     * @param  string $login_token  (optional)
     * @param  string[] $login_token2  (optional)
     * @param  bool $send_new_appointment_email  (optional)
     * @param  bool[] $send_new_appointment_email2  (optional)
     * @param  bool $send_test_evaluated_email  (optional)
     * @param  bool[] $send_test_evaluated_email2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersGetCollectionAsync($page = 1, $roles = null, $roles2 = null, $password = null, $password2 = null, $username = null, $username2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $mfa_enabled = null, $mfa_enabled2 = null, $active = null, $active2 = null, $deleted = null, $deleted2 = null, $login_token = null, $login_token2 = null, $send_new_appointment_email = null, $send_new_appointment_email2 = null, $send_test_evaluated_email = null, $send_test_evaluated_email2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalusersGetCollection'][0])
    {
        return $this->apiApiInternalusersGetCollectionAsyncWithHttpInfo($page, $roles, $roles2, $password, $password2, $username, $username2, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $mfa_enabled, $mfa_enabled2, $active, $active2, $deleted, $deleted2, $login_token, $login_token2, $send_new_appointment_email, $send_new_appointment_email2, $send_test_evaluated_email, $send_test_evaluated_email2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalusersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of User resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $roles  (optional)
     * @param  string[] $roles2  (optional)
     * @param  string $password  (optional)
     * @param  string[] $password2  (optional)
     * @param  string $username  (optional)
     * @param  string[] $username2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  bool $mfa_enabled  (optional)
     * @param  bool[] $mfa_enabled2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  bool $deleted  (optional)
     * @param  bool[] $deleted2  (optional)
     * @param  string $login_token  (optional)
     * @param  string[] $login_token2  (optional)
     * @param  bool $send_new_appointment_email  (optional)
     * @param  bool[] $send_new_appointment_email2  (optional)
     * @param  bool $send_test_evaluated_email  (optional)
     * @param  bool[] $send_test_evaluated_email2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersGetCollectionAsyncWithHttpInfo($page = 1, $roles = null, $roles2 = null, $password = null, $password2 = null, $username = null, $username2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $mfa_enabled = null, $mfa_enabled2 = null, $active = null, $active2 = null, $deleted = null, $deleted2 = null, $login_token = null, $login_token2 = null, $send_new_appointment_email = null, $send_new_appointment_email2 = null, $send_test_evaluated_email = null, $send_test_evaluated_email2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalusersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User[]';
        $request = $this->apiApiInternalusersGetCollectionRequest($page, $roles, $roles2, $password, $password2, $username, $username2, $first_name, $first_name2, $last_name, $last_name2, $email, $email2, $mfa_enabled, $mfa_enabled2, $active, $active2, $deleted, $deleted2, $login_token, $login_token2, $send_new_appointment_email, $send_new_appointment_email2, $send_test_evaluated_email, $send_test_evaluated_email2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalusersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $roles  (optional)
     * @param  string[] $roles2  (optional)
     * @param  string $password  (optional)
     * @param  string[] $password2  (optional)
     * @param  string $username  (optional)
     * @param  string[] $username2  (optional)
     * @param  string $first_name  (optional)
     * @param  string[] $first_name2  (optional)
     * @param  string $last_name  (optional)
     * @param  string[] $last_name2  (optional)
     * @param  string $email  (optional)
     * @param  string[] $email2  (optional)
     * @param  bool $mfa_enabled  (optional)
     * @param  bool[] $mfa_enabled2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  bool $deleted  (optional)
     * @param  bool[] $deleted2  (optional)
     * @param  string $login_token  (optional)
     * @param  string[] $login_token2  (optional)
     * @param  bool $send_new_appointment_email  (optional)
     * @param  bool[] $send_new_appointment_email2  (optional)
     * @param  bool $send_test_evaluated_email  (optional)
     * @param  bool[] $send_test_evaluated_email2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalusersGetCollectionRequest($page = 1, $roles = null, $roles2 = null, $password = null, $password2 = null, $username = null, $username2 = null, $first_name = null, $first_name2 = null, $last_name = null, $last_name2 = null, $email = null, $email2 = null, $mfa_enabled = null, $mfa_enabled2 = null, $active = null, $active2 = null, $deleted = null, $deleted2 = null, $login_token = null, $login_token2 = null, $send_new_appointment_email = null, $send_new_appointment_email2 = null, $send_test_evaluated_email = null, $send_test_evaluated_email2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalusersGetCollection'][0])
    {

































        $resourcePath = '/api-internal/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $roles,
            'roles', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $roles2,
            'roles[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $password,
            'password', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $password2,
            'password[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username,
            'username', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $username2,
            'username[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name,
            'firstName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $first_name2,
            'firstName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name,
            'lastName', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_name2,
            'lastName[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email,
            'email', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $email2,
            'email[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mfa_enabled,
            'mfaEnabled', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $mfa_enabled2,
            'mfaEnabled[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active2,
            'active[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deleted,
            'deleted', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $deleted2,
            'deleted[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $login_token,
            'loginToken', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $login_token2,
            'loginToken[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_new_appointment_email,
            'sendNewAppointmentEmail', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_new_appointment_email2,
            'sendNewAppointmentEmail[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_test_evaluated_email,
            'sendTestEvaluatedEmail', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $send_test_evaluated_email2,
            'sendTestEvaluatedEmail[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalusersPost
     *
     * Creates a User resource.
     *
     * @param  \OpenAPI\Client\Model\User $user The new User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function apiApiInternalusersPost($user, string $contentType = self::contentTypes['apiApiInternalusersPost'][0])
    {
        list($response) = $this->apiApiInternalusersPostWithHttpInfo($user, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalusersPostWithHttpInfo
     *
     * Creates a User resource.
     *
     * @param  \OpenAPI\Client\Model\User $user The new User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalusersPostWithHttpInfo($user, string $contentType = self::contentTypes['apiApiInternalusersPost'][0])
    {
        $request = $this->apiApiInternalusersPostRequest($user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalusersPostAsync
     *
     * Creates a User resource.
     *
     * @param  \OpenAPI\Client\Model\User $user The new User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersPostAsync($user, string $contentType = self::contentTypes['apiApiInternalusersPost'][0])
    {
        return $this->apiApiInternalusersPostAsyncWithHttpInfo($user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalusersPostAsyncWithHttpInfo
     *
     * Creates a User resource.
     *
     * @param  \OpenAPI\Client\Model\User $user The new User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersPostAsyncWithHttpInfo($user, string $contentType = self::contentTypes['apiApiInternalusersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->apiApiInternalusersPostRequest($user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalusersPost'
     *
     * @param  \OpenAPI\Client\Model\User $user The new User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalusersPostRequest($user, string $contentType = self::contentTypes['apiApiInternalusersPost'][0])
    {

        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling apiApiInternalusersPost'
            );
        }


        $resourcePath = '/api-internal/users';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user));
            } else {
                $httpBody = $user;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalusersUuidGet
     *
     * Retrieves a User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function apiApiInternalusersUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalusersUuidGet'][0])
    {
        list($response) = $this->apiApiInternalusersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalusersUuidGetWithHttpInfo
     *
     * Retrieves a User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalusersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalusersUuidGet'][0])
    {
        $request = $this->apiApiInternalusersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalusersUuidGetAsync
     *
     * Retrieves a User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalusersUuidGet'][0])
    {
        return $this->apiApiInternalusersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalusersUuidGetAsyncWithHttpInfo
     *
     * Retrieves a User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalusersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->apiApiInternalusersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalusersUuidGet'
     *
     * @param  string $uuid User identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalusersUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalusersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalusersUuidGet'
            );
        }


        $resourcePath = '/api-internal/users/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalusersUuidPatch
     *
     * Updates the User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  \OpenAPI\Client\Model\User $user The updated User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\User
     */
    public function apiApiInternalusersUuidPatch($uuid, $user, string $contentType = self::contentTypes['apiApiInternalusersUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalusersUuidPatchWithHttpInfo($uuid, $user, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalusersUuidPatchWithHttpInfo
     *
     * Updates the User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  \OpenAPI\Client\Model\User $user The updated User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\User, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalusersUuidPatchWithHttpInfo($uuid, $user, string $contentType = self::contentTypes['apiApiInternalusersUuidPatch'][0])
    {
        $request = $this->apiApiInternalusersUuidPatchRequest($uuid, $user, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\User' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\User' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\User', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\User';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\User',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalusersUuidPatchAsync
     *
     * Updates the User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  \OpenAPI\Client\Model\User $user The updated User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersUuidPatchAsync($uuid, $user, string $contentType = self::contentTypes['apiApiInternalusersUuidPatch'][0])
    {
        return $this->apiApiInternalusersUuidPatchAsyncWithHttpInfo($uuid, $user, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalusersUuidPatchAsyncWithHttpInfo
     *
     * Updates the User resource.
     *
     * @param  string $uuid User identifier (required)
     * @param  \OpenAPI\Client\Model\User $user The updated User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalusersUuidPatchAsyncWithHttpInfo($uuid, $user, string $contentType = self::contentTypes['apiApiInternalusersUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\User';
        $request = $this->apiApiInternalusersUuidPatchRequest($uuid, $user, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalusersUuidPatch'
     *
     * @param  string $uuid User identifier (required)
     * @param  \OpenAPI\Client\Model\User $user The updated User resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalusersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalusersUuidPatchRequest($uuid, $user, string $contentType = self::contentTypes['apiApiInternalusersUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalusersUuidPatch'
            );
        }

        // verify the required parameter 'user' is set
        if ($user === null || (is_array($user) && count($user) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $user when calling apiApiInternalusersUuidPatch'
            );
        }


        $resourcePath = '/api-internal/users/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($user)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($user));
            } else {
                $httpBody = $user;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalvouchersGetCollection
     *
     * Retrieves the collection of Voucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $code  (optional)
     * @param  string[] $code2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $valid_from  (optional)
     * @param  string $valid_from2  (optional)
     * @param  string $valid_to  (optional)
     * @param  string $valid_to2  (optional)
     * @param  int $quantity  (optional)
     * @param  int[] $quantity2  (optional)
     * @param  int $quantity_per_person  (optional)
     * @param  int[] $quantity_per_person2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Voucher[]
     */
    public function apiApiInternalvouchersGetCollection($page = 1, $code = null, $code2 = null, $voucher_comment = null, $voucher_comment2 = null, $value = null, $value2 = null, $voucher_type = null, $voucher_type2 = null, $valid_from = null, $valid_from2 = null, $valid_to = null, $valid_to2 = null, $quantity = null, $quantity2 = null, $quantity_per_person = null, $quantity_per_person2 = null, $active = null, $active2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalvouchersGetCollection'][0])
    {
        list($response) = $this->apiApiInternalvouchersGetCollectionWithHttpInfo($page, $code, $code2, $voucher_comment, $voucher_comment2, $value, $value2, $voucher_type, $voucher_type2, $valid_from, $valid_from2, $valid_to, $valid_to2, $quantity, $quantity2, $quantity_per_person, $quantity_per_person2, $active, $active2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalvouchersGetCollectionWithHttpInfo
     *
     * Retrieves the collection of Voucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $code  (optional)
     * @param  string[] $code2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $valid_from  (optional)
     * @param  string $valid_from2  (optional)
     * @param  string $valid_to  (optional)
     * @param  string $valid_to2  (optional)
     * @param  int $quantity  (optional)
     * @param  int[] $quantity2  (optional)
     * @param  int $quantity_per_person  (optional)
     * @param  int[] $quantity_per_person2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Voucher[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalvouchersGetCollectionWithHttpInfo($page = 1, $code = null, $code2 = null, $voucher_comment = null, $voucher_comment2 = null, $value = null, $value2 = null, $voucher_type = null, $voucher_type2 = null, $valid_from = null, $valid_from2 = null, $valid_to = null, $valid_to2 = null, $quantity = null, $quantity2 = null, $quantity_per_person = null, $quantity_per_person2 = null, $active = null, $active2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalvouchersGetCollection'][0])
    {
        $request = $this->apiApiInternalvouchersGetCollectionRequest($page, $code, $code2, $voucher_comment, $voucher_comment2, $value, $value2, $voucher_type, $voucher_type2, $valid_from, $valid_from2, $valid_to, $valid_to2, $quantity, $quantity2, $quantity_per_person, $quantity_per_person2, $active, $active2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Voucher[]' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Voucher[]' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Voucher[]', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Voucher[]';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Voucher[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalvouchersGetCollectionAsync
     *
     * Retrieves the collection of Voucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $code  (optional)
     * @param  string[] $code2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $valid_from  (optional)
     * @param  string $valid_from2  (optional)
     * @param  string $valid_to  (optional)
     * @param  string $valid_to2  (optional)
     * @param  int $quantity  (optional)
     * @param  int[] $quantity2  (optional)
     * @param  int $quantity_per_person  (optional)
     * @param  int[] $quantity_per_person2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersGetCollectionAsync($page = 1, $code = null, $code2 = null, $voucher_comment = null, $voucher_comment2 = null, $value = null, $value2 = null, $voucher_type = null, $voucher_type2 = null, $valid_from = null, $valid_from2 = null, $valid_to = null, $valid_to2 = null, $quantity = null, $quantity2 = null, $quantity_per_person = null, $quantity_per_person2 = null, $active = null, $active2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalvouchersGetCollection'][0])
    {
        return $this->apiApiInternalvouchersGetCollectionAsyncWithHttpInfo($page, $code, $code2, $voucher_comment, $voucher_comment2, $value, $value2, $voucher_type, $voucher_type2, $valid_from, $valid_from2, $valid_to, $valid_to2, $quantity, $quantity2, $quantity_per_person, $quantity_per_person2, $active, $active2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalvouchersGetCollectionAsyncWithHttpInfo
     *
     * Retrieves the collection of Voucher resources.
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $code  (optional)
     * @param  string[] $code2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $valid_from  (optional)
     * @param  string $valid_from2  (optional)
     * @param  string $valid_to  (optional)
     * @param  string $valid_to2  (optional)
     * @param  int $quantity  (optional)
     * @param  int[] $quantity2  (optional)
     * @param  int $quantity_per_person  (optional)
     * @param  int[] $quantity_per_person2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersGetCollectionAsyncWithHttpInfo($page = 1, $code = null, $code2 = null, $voucher_comment = null, $voucher_comment2 = null, $value = null, $value2 = null, $voucher_type = null, $voucher_type2 = null, $valid_from = null, $valid_from2 = null, $valid_to = null, $valid_to2 = null, $quantity = null, $quantity2 = null, $quantity_per_person = null, $quantity_per_person2 = null, $active = null, $active2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalvouchersGetCollection'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Voucher[]';
        $request = $this->apiApiInternalvouchersGetCollectionRequest($page, $code, $code2, $voucher_comment, $voucher_comment2, $value, $value2, $voucher_type, $voucher_type2, $valid_from, $valid_from2, $valid_to, $valid_to2, $quantity, $quantity2, $quantity_per_person, $quantity_per_person2, $active, $active2, $created_at, $created_at2, $updated_at, $updated_at2, $uuid, $uuid2, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalvouchersGetCollection'
     *
     * @param  int $page The collection page number (optional, default to 1)
     * @param  string $code  (optional)
     * @param  string[] $code2  (optional)
     * @param  string $voucher_comment  (optional)
     * @param  string[] $voucher_comment2  (optional)
     * @param  int $value  (optional)
     * @param  int[] $value2  (optional)
     * @param  string $voucher_type  (optional)
     * @param  string[] $voucher_type2  (optional)
     * @param  string $valid_from  (optional)
     * @param  string $valid_from2  (optional)
     * @param  string $valid_to  (optional)
     * @param  string $valid_to2  (optional)
     * @param  int $quantity  (optional)
     * @param  int[] $quantity2  (optional)
     * @param  int $quantity_per_person  (optional)
     * @param  int[] $quantity_per_person2  (optional)
     * @param  bool $active  (optional)
     * @param  bool[] $active2  (optional)
     * @param  string $created_at  (optional)
     * @param  string $created_at2  (optional)
     * @param  string $updated_at  (optional)
     * @param  string $updated_at2  (optional)
     * @param  string $uuid  (optional)
     * @param  string[] $uuid2  (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersGetCollection'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalvouchersGetCollectionRequest($page = 1, $code = null, $code2 = null, $voucher_comment = null, $voucher_comment2 = null, $value = null, $value2 = null, $voucher_type = null, $voucher_type2 = null, $valid_from = null, $valid_from2 = null, $valid_to = null, $valid_to2 = null, $quantity = null, $quantity2 = null, $quantity_per_person = null, $quantity_per_person2 = null, $active = null, $active2 = null, $created_at = null, $created_at2 = null, $updated_at = null, $updated_at2 = null, $uuid = null, $uuid2 = null, string $contentType = self::contentTypes['apiApiInternalvouchersGetCollection'][0])
    {



























        $resourcePath = '/api-internal/vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code2,
            'code[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_comment,
            'voucherComment', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_comment2,
            'voucherComment[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value,
            'value', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $value2,
            'value[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_type,
            'voucherType', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $voucher_type2,
            'voucherType[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valid_from,
            'validFrom', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valid_from2,
            'validFrom[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valid_to,
            'validTo', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $valid_to2,
            'validTo[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity,
            'quantity', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity2,
            'quantity[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity_per_person,
            'quantityPerPerson', // param base name
            'integer', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $quantity_per_person2,
            'quantityPerPerson[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active,
            'active', // param base name
            'boolean', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $active2,
            'active[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at,
            'createdAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_at2,
            'createdAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at,
            'updatedAt', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $updated_at2,
            'updatedAt[]', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid,
            'uuid', // param base name
            'string', // openApiType
            'form', // style
            false, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $uuid2,
            'uuid[]', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalvouchersPost
     *
     * Creates a Voucher resource.
     *
     * @param  \OpenAPI\Client\Model\Voucher $voucher The new Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Voucher
     */
    public function apiApiInternalvouchersPost($voucher, string $contentType = self::contentTypes['apiApiInternalvouchersPost'][0])
    {
        list($response) = $this->apiApiInternalvouchersPostWithHttpInfo($voucher, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalvouchersPostWithHttpInfo
     *
     * Creates a Voucher resource.
     *
     * @param  \OpenAPI\Client\Model\Voucher $voucher The new Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersPost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Voucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalvouchersPostWithHttpInfo($voucher, string $contentType = self::contentTypes['apiApiInternalvouchersPost'][0])
    {
        $request = $this->apiApiInternalvouchersPostRequest($voucher, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 201:
                    if ('\OpenAPI\Client\Model\Voucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Voucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Voucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Voucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Voucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalvouchersPostAsync
     *
     * Creates a Voucher resource.
     *
     * @param  \OpenAPI\Client\Model\Voucher $voucher The new Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersPostAsync($voucher, string $contentType = self::contentTypes['apiApiInternalvouchersPost'][0])
    {
        return $this->apiApiInternalvouchersPostAsyncWithHttpInfo($voucher, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalvouchersPostAsyncWithHttpInfo
     *
     * Creates a Voucher resource.
     *
     * @param  \OpenAPI\Client\Model\Voucher $voucher The new Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersPostAsyncWithHttpInfo($voucher, string $contentType = self::contentTypes['apiApiInternalvouchersPost'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Voucher';
        $request = $this->apiApiInternalvouchersPostRequest($voucher, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalvouchersPost'
     *
     * @param  \OpenAPI\Client\Model\Voucher $voucher The new Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalvouchersPostRequest($voucher, string $contentType = self::contentTypes['apiApiInternalvouchersPost'][0])
    {

        // verify the required parameter 'voucher' is set
        if ($voucher === null || (is_array($voucher) && count($voucher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $voucher when calling apiApiInternalvouchersPost'
            );
        }


        $resourcePath = '/api-internal/vouchers';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($voucher)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($voucher));
            } else {
                $httpBody = $voucher;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalvouchersUuidGet
     *
     * Retrieves a Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Voucher
     */
    public function apiApiInternalvouchersUuidGet($uuid, string $contentType = self::contentTypes['apiApiInternalvouchersUuidGet'][0])
    {
        list($response) = $this->apiApiInternalvouchersUuidGetWithHttpInfo($uuid, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalvouchersUuidGetWithHttpInfo
     *
     * Retrieves a Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Voucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalvouchersUuidGetWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalvouchersUuidGet'][0])
    {
        $request = $this->apiApiInternalvouchersUuidGetRequest($uuid, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Voucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Voucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Voucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Voucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Voucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalvouchersUuidGetAsync
     *
     * Retrieves a Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersUuidGetAsync($uuid, string $contentType = self::contentTypes['apiApiInternalvouchersUuidGet'][0])
    {
        return $this->apiApiInternalvouchersUuidGetAsyncWithHttpInfo($uuid, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalvouchersUuidGetAsyncWithHttpInfo
     *
     * Retrieves a Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersUuidGetAsyncWithHttpInfo($uuid, string $contentType = self::contentTypes['apiApiInternalvouchersUuidGet'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Voucher';
        $request = $this->apiApiInternalvouchersUuidGetRequest($uuid, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalvouchersUuidGet'
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalvouchersUuidGetRequest($uuid, string $contentType = self::contentTypes['apiApiInternalvouchersUuidGet'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalvouchersUuidGet'
            );
        }


        $resourcePath = '/api-internal/vouchers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiApiInternalvouchersUuidPatch
     *
     * Updates the Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  \OpenAPI\Client\Model\Voucher $voucher The updated Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\Voucher
     */
    public function apiApiInternalvouchersUuidPatch($uuid, $voucher, string $contentType = self::contentTypes['apiApiInternalvouchersUuidPatch'][0])
    {
        list($response) = $this->apiApiInternalvouchersUuidPatchWithHttpInfo($uuid, $voucher, $contentType);
        return $response;
    }

    /**
     * Operation apiApiInternalvouchersUuidPatchWithHttpInfo
     *
     * Updates the Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  \OpenAPI\Client\Model\Voucher $voucher The updated Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\Voucher, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiApiInternalvouchersUuidPatchWithHttpInfo($uuid, $voucher, string $contentType = self::contentTypes['apiApiInternalvouchersUuidPatch'][0])
    {
        $request = $this->apiApiInternalvouchersUuidPatchRequest($uuid, $voucher, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\OpenAPI\Client\Model\Voucher' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\OpenAPI\Client\Model\Voucher' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\OpenAPI\Client\Model\Voucher', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\OpenAPI\Client\Model\Voucher';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\Voucher',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiApiInternalvouchersUuidPatchAsync
     *
     * Updates the Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  \OpenAPI\Client\Model\Voucher $voucher The updated Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersUuidPatchAsync($uuid, $voucher, string $contentType = self::contentTypes['apiApiInternalvouchersUuidPatch'][0])
    {
        return $this->apiApiInternalvouchersUuidPatchAsyncWithHttpInfo($uuid, $voucher, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiApiInternalvouchersUuidPatchAsyncWithHttpInfo
     *
     * Updates the Voucher resource.
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  \OpenAPI\Client\Model\Voucher $voucher The updated Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiApiInternalvouchersUuidPatchAsyncWithHttpInfo($uuid, $voucher, string $contentType = self::contentTypes['apiApiInternalvouchersUuidPatch'][0])
    {
        $returnType = '\OpenAPI\Client\Model\Voucher';
        $request = $this->apiApiInternalvouchersUuidPatchRequest($uuid, $voucher, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiApiInternalvouchersUuidPatch'
     *
     * @param  string $uuid Voucher identifier (required)
     * @param  \OpenAPI\Client\Model\Voucher $voucher The updated Voucher resource (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiApiInternalvouchersUuidPatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiApiInternalvouchersUuidPatchRequest($uuid, $voucher, string $contentType = self::contentTypes['apiApiInternalvouchersUuidPatch'][0])
    {

        // verify the required parameter 'uuid' is set
        if ($uuid === null || (is_array($uuid) && count($uuid) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $uuid when calling apiApiInternalvouchersUuidPatch'
            );
        }

        // verify the required parameter 'voucher' is set
        if ($voucher === null || (is_array($voucher) && count($voucher) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $voucher when calling apiApiInternalvouchersUuidPatch'
            );
        }


        $resourcePath = '/api-internal/vouchers/{uuid}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($uuid !== null) {
            $resourcePath = str_replace(
                '{' . 'uuid' . '}',
                ObjectSerializer::toPathValue($uuid),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'application/ld+json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($voucher)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($voucher));
            } else {
                $httpBody = $voucher;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires API key authentication
        $apiKey = $this->config->getApiKeyWithPrefix('X-AUTH-TOKEN');
        if ($apiKey !== null) {
            $headers['X-AUTH-TOKEN'] = $apiKey;
        }
        // this endpoint requires Bearer (JWT) authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PATCH',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
